<!DOCTYPE html>
<html lang="en">

<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Sup Lotto Terminal v5.34 ‚Äî Production</title>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
<style>
/* Unchanged CSS from previous version */
html, body { height: 100%; margin: 0; padding: 0; background: #000; font-family: 'Orbitron', sans-serif; color: #00b33c; }
body { display: flex; align-items: center; justify-content: center; padding: 20px; }
.terminal { width: 920px; max-width: 94vw; background: #111111; border: 2px solid #00b33c; border-radius: 12px; padding: 18px; box-sizing: border-box; box-shadow: 0 6px 30px rgba(0,179,60,0.06); }
.header { text-align: center; font-size: 20px; font-weight: 900; margin-bottom: 14px; color: #00b33c; }
.status-thread { min-height: 60px; max-height: 100px; overflow-y: auto; margin-bottom: 12px; color: #80cc99; font-size: 12px; opacity: 0.85; border: 1px solid rgba(0,179,60,0.2); border-radius: 6px; padding: 8px; }
.status-thread .event { opacity: 1; animation: fadeIn 0.5s ease-in; }
.status-thread .event.fade-out { opacity: 0; transition: opacity 1s ease-out; }
@keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
.network-section { margin-bottom: 12px; }
.search-section { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; margin-bottom: 12px; }
.search-section input, .search-section select, .search-section button { background: #1a1a1a; color: #00b33c; border: 1px solid #00b33c; padding: 6px 8px; border-radius: 6px; font-family: 'Orbitron'; font-size: 13px; }
.search-section button { cursor: pointer; }
.search-section button:hover { background: #00b33c; color: #000; }
.lotto-list { display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 12px; align-items: start; }
.lotto-card { background: #1a1a1a; border: 1px solid rgba(0,179,60,0.18); padding: 10px; border-radius: 10px; cursor: pointer; transition: transform .12s ease, box-shadow .12s ease; font-size: 12px; height: 200px; display: flex; flex-direction: column; justify-content: flex-start; box-sizing: border-box; }
.lotto-card:hover { transform: translateY(-6px); box-shadow: 0 8px 24px rgba(0,0,0,0.7); }
.lotto-card.open { border: 2px solid #00b33c; background: #222222; transform: scale(1.05); }
.lotto-card.closed { border: 1px solid rgba(255,255,255,0.2); background: #222222; opacity: 0.85; }
.lotto-card.winner { animation: winnerGlow 1.5s ease-in-out infinite; border: 2px solid #ccac00; background: #2a2a00; }
@keyframes winnerGlow { 0% { box-shadow: 0 0 10px #ccac00, 0 0 20px rgba(204,172,0,0.5); } 50% { box-shadow: 0 0 20px #ccac00, 0 0 30px rgba(204,172,0,0.8); } 100% { box-shadow: 0 0 10px #ccac00, 0 0 20px rgba(204,172,0,0.5); } }
.lotto-card .card-top { display: flex; align-items: center; gap: 8px; }
.lotto-card .card-badge { font-size: 11px; padding: 3px 6px; border-radius: 6px; background: #002b00; color: #80cc99; }
.spoiled-badge { background: #661616; color: #fff; padding: 3px 6px; border-radius: 6px; display: inline-block; font-size: 11px; }
.lotto-image { width: 100%; height: 50px; object-fit: cover; border-radius: 8px; margin-top: 8px; background: linear-gradient(180deg, #0b0b0b, #191919); }
.winner-highlight { position: absolute; top: 0; left: 0; right: 0; background: rgba(204,172,0,0.8); color: #000; font-size: 10px; font-weight: 700; text-align: center; padding: 4px; border-radius: 8px 8px 0 0; }
.winner-highlight::after { content: 'üèÜ'; position: absolute; right: 4px; top: 4px; font-size: 14px; }
.lotto-message { font-size: 11px; color: #b3ccbb; margin-top: 6px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.lotto-meta { margin-top: 8px; line-height: 1.15; color: #80cc99; flex-grow: 1; }
.lotto-meta a { color: #80cc99; text-decoration: none; }
.lotto-meta .non-official { color: #ff8080; font-weight: 700; }
.lotto-card button { margin-top: 8px; align-self: flex-end; background: #00b33c; color: #000; border: none; padding: 6px 8px; border-radius: 6px; cursor: pointer; font-weight: 700; }
.modal-overlay { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.78); z-index: 1200; align-items: center; justify-content: center; padding: 20px; }
.modal { background: #111111; border: 2px solid #00b33c; max-width: 760px; width: 100%; max-height: 84vh; overflow: hidden; border-radius: 10px; display: flex; flex-direction: column; }
.modal-header { padding: 12px 16px; border-bottom: 1px solid rgba(0,179,60,0.08); font-weight: 800; }
.modal-body { padding: 12px 16px; overflow: auto; flex: 1; }
.modal-body label { display: block; margin-top: 8px; font-size: 12px; color: #80cc99; }
.ticket-thread { display: flex; flex-direction: column; gap: 8px; padding-bottom: 8px; }
.ticket-entry { background: #0b0b0b; border: 1px solid rgba(0,179,60,0.08); padding: 10px; border-radius: 10px; font-size: 13px; color: #b3ccbb; }
.ticket-entry img.ticket-image { width: 100%; max-height: 300px; object-fit: cover; margin-top: 8px; border-radius: 8px; }
.ticket-entry.winner { border: 2px solid #ccac00; background: #2a2a00; position: relative; }
.ticket-entry.winner::before { content: 'Winner üèÜ'; position: absolute; top: 0; left: 0; right: 0; background: rgba(204,172,0,0.8); color: #000; font-size: 10px; font-weight: 700; text-align: center; padding: 4px; border-radius: 8px 8px 0 0; }
.modal input, .modal select, .modal textarea { background: #1a1a1a; color: #00b33c; border: 1px solid #00b33c; padding: 8px; border-radius: 6px; width: 100%; box-sizing: border-box; margin-top: 4px; }
.error-log { max-height: 80px; overflow: auto; margin-top: 10px; color: #ff4444; font-size: 12px; display: none; }
</style>
</head>
<body>
<div class="terminal" id="terminal">
  <div class="header">üöÄ Sup!? LOTTO TERMINAL v5.34 üöÄ<br><small>Grid Matrix Jackpot ‚Äî Production</small></div>
  <div class="status-thread" id="statusThread"><div>Ready.</div></div>
  <div class="network-section">
    <label for="mainnet">Mainnet:</label>
    <input type="checkbox" id="mainnet">
  </div>
  <div class="search-section">
    <input id="keyword" placeholder="Keyword (e.g., ASTRO)" maxlength="20">
    <select id="lottoType">
      <option value="">Any Type</option>
      <option value="pb">Powerball (PB)</option>
      <option value="mg">Mega (MG)</option>
      <option value="sc">Scratch (SC)</option>
    </select>
    <select id="statusFilter">
      <option value="">Any Status</option>
      <option value="OPEN">OPEN</option>
      <option value="CLOSED">CLOSED</option>
      <option value="SPOILED">SPOILED</option>
      <option value="PENDING">PENDING</option>
    </select>
    <select id="prizeFilter">
      <option value="">Any Prize</option>
    </select>
    <button id="scanBtn">üîç SCAN</button>
    <button id="createBtn">‚ú® CREATE</button>
  </div>
  <div class="lotto-list" id="lottoList"></div>
  <div class="modal-overlay" id="createModalOverlay" aria-hidden="true">
    <div class="modal">
      <div class="modal-header">‚ú® CREATE NEW LOTTO</div>
      <div class="modal-body">
        <label for="createLottoId">Keyword</label>
        <input id="createLottoId" placeholder="Keyword (max 20)">
        <label for="createLottoType">Lotto Type</label>
        <select id="createLottoType">
          <option value="">Select Type</option>
          <option value="pb">Powerball (PB)</option>
          <option value="mg">Mega (MG)</option>
          <option value="sc">Scratch (SC)</option>
        </select>
        <label for="createPrizeModal">Prize</label>
        <input id="createPrizeModal" list="prizeOptions" placeholder="Prize (e.g., 100 TRX)">
        <datalist id="prizeOptions"></datalist>
        <label for="createQty">Quantity</label>
        <input type="number" id="createQty" min="1" placeholder="Quantity" value="1">
        <label for="createDuration">Duration (hours)</label>
        <input type="number" id="createDuration" min="1" placeholder="Duration (hours)" value="1">
        <div style="text-align:right;margin-top:8px;">
          <button id="createSubmitBtn">üöÄ CREATE LOTTO</button>
          <button id="createCancelBtn">‚ùå CANCEL</button>
        </div>
      </div>
    </div>
  </div>
  <div class="modal-overlay" id="copyModalOverlay" aria-hidden="true">
    <div class="modal">
      <div class="modal-header">üìã COPY LOTTO SCRIPT</div>
      <div class="modal-body">
        <textarea id="copyScript" readonly style="height:100px;resize:none;"></textarea>
        <div style="text-align:right;margin-top:8px;">
          <button id="copyBtn">üìã COPY</button>
          <button id="copyCloseBtn">‚ùå CLOSE</button>
        </div>
      </div>
    </div>
  </div>
  <div class="modal-overlay" id="ticketOverlay" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true">
      <div class="modal-header">üé´ TICKET THREAD</div>
      <div class="modal-body">
        <div class="ticket-thread" id="ticketThread"></div>
        <div style="text-align:right;margin-top:8px;">
          <button id="ticketCloseBtn">‚ùå CLOSE</button>
        </div>
      </div>
    </div>
  </div>
  <div class="error-log" id="errorLog" style="display:none"></div>
  <audio id="initBeep" preload="auto">
    <source src="https://freesound.org/data/previews/100/100981_1648170-lq.mp3" type="audio/mpeg">
  </audio>
  <audio id="openSound" preload="auto">
    <source src="https://mixkit.co/free-sound-effects/download/1428/?format=mp3" type="audio/mpeg">
  </audio>
  <audio id="expireSound" preload="auto">
    <source src="https://freesound.org/data/previews/80/80921_1022651-lq.mp3" type="audio/mpeg">
  </audio>
  <audio id="ticketSound" preload="auto">
    <source src="https://mixkit.co/free-sound-effects/download/1390/?format=mp3" type="audio/mpeg">
  </audio>
  <audio id="winnerSound" preload="auto">
    <source src="https://mixkit.co/free-sound-effects/download/1421/?format=mp3" type="audio/mpeg">
  </audio>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.4/moment.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/moment-timezone/0.5.34/moment-timezone-with-data.min.js"></script>
<script>
/* ---------------------- Constants & Small Helpers ---------------------- */
const MASTER_KEYWORD = "MatrixCore";
const MESSAGE_KEYWORD = "#MatrixCore";
const API_BASE = "https://p2fk.io";
const POLL_MS = 10000;
const NORMAL_FETCH_QTY = 500;
const INIT_FETCH_QTY = 10000;
const URN_CACHE_TIMEOUT = 3600000;
const API_TIMEOUT_MS = 15000;
const TICKET_BUFFER_MINUTES = 22;
const VALID_IMAGE_EXTENSIONS = ['.jpg','.jpeg','.png','.gif','.webp'];
const INITIAL_TICKET_RENDER_LIMIT = 50;
const MAX_CONCURRENT_REQUESTS = 2;
const IMAGE_FETCH_DELAY_MS = 100;
const IPFS_RETRY_ATTEMPTS = 3;
const NON_IMAGE_EXTENSIONS = ['.txt','.pdf','.doc','.docx','.xls','.xlsx'];
const IPFS_GATEWAYS = ['https://ipfs.io/ipfs/','https://cloudflare-ipfs.com/ipfs/','https://gateway.pinata.cloud/ipfs/'];
const $ = id => document.getElementById(id);

/* ---------------------- Sound Playback ---------------------- */
function playSound(soundId) {
  const sound = $(soundId);
  if (sound) {
    sound.currentTime = 0;
    sound.play().catch(() => {
      document.addEventListener('click', () => sound.play(), { once: true });
    });
  }
}

/* ---------------------- Minimal/no-op logging for production (fast) ---------------------- */
function logStatus(msg, type = 'info') {
  const statusThread = $('statusThread');
  if (!statusThread) return;
  const eventDiv = document.createElement('div');
  eventDiv.className = 'event';
  eventDiv.textContent = `[${moment().tz('America/Denver').format('HH:mm:ss')}] ${msg}`;
  statusThread.prepend(eventDiv);
  setTimeout(() => {
    eventDiv.classList.add('fade-out');
    setTimeout(() => eventDiv.remove(), 1000);
  }, 5000);
}
function logError(msg) { console.log(msg); } // Temporary for debugging images

/* ---------------------- Globals & caches ---------------------- */
let isMainnet = false;
let masterAddress = null;
const cache = {
  sessions: new Map(),
  prizes: new Set(),
  types: new Set(['pb', 'mg', 'sc']),
  tickets: new Map(),
  urns: new Map(),
  imageCache: new Map()
};
const processedTxIds = new Set();
let ticketObserver = null;
let lastDisplayLottos = 0;

/* ---------------------- Promise Queue ---------------------- */
class PromiseQueue {
  constructor(maxConcurrent) { this.maxConcurrent = maxConcurrent; this.running = 0; this.queue = []; }
  add(promiseCreator) {
    return new Promise((resolve, reject) => {
      this.queue.push({ promiseCreator, resolve, reject });
      this.run();
    });
  }
  async run() {
    if (this.running >= this.maxConcurrent || !this.queue.length) return;
    this.running++;
    const { promiseCreator, resolve, reject } = this.queue.shift();
    try {
      const result = await promiseCreator();
      resolve(result);
    } catch (e) {
      reject(e);
    } finally {
      this.running--;
      setTimeout(() => this.run(), IMAGE_FETCH_DELAY_MS);
    }
  }
}
const requestQueue = new PromiseQueue(MAX_CONCURRENT_REQUESTS);
const imageFetchQueue = new PromiseQueue(MAX_CONCURRENT_REQUESTS);

/* ---------------------- Utility: RNG, ensure arrays ---------------------- */
function createSeededRNG(seedStr) {
  let seed = 0;
  for (let i = 0; i < seedStr.length; i++) {
    seed = (seed * 31 + seedStr.charCodeAt(i)) & 0x7FFFFFFF;
  }
  return function() {
    seed = (seed * 1664525 + 1013904223) & 0x7FFFFFFF;
    return seed / 0x7FFFFFFF;
  };
}
function ensureSessionArray(base) {
  if (!cache.sessions.has(base)) cache.sessions.set(base, []);
  return cache.sessions.get(base);
}
function ensureTicketArray(base) {
  if (!cache.tickets.has(base)) cache.tickets.set(base, []);
  return cache.tickets.get(base);
}
function normalizeBaseId(raw) {
  if (!raw) return '';
  return raw.trim().replace(/^#+/, '').replace(/\s+/g, '').replace(/[^A-Za-z0-9]/g, '').toUpperCase();
}

/* ---------------------- Core: winner selection & session updates ---------------------- */
function selectWinner(session) {
  if (!session.tickets || session.tickets.length === 0) return null;
  const seedStr = session.txid + session.tickets.map(t => t.txid).join('');
  const rng = createSeededRNG(seedStr);
  const total = session.tickets.reduce((s, t) => s + (t.weight || 1), 0);
  let r = rng() * total;
  for (const ticket of session.tickets) {
    r -= (ticket.weight || 1);
    if (r <= 0) {
      playSound('winnerSound');
      logError(`selectWinner: Selected winner ${ticket.player.substring(0, 8)} for session ${session.txid}`);
      return ticket.player;
    }
  }
  playSound('winnerSound');
  logError(`selectWinner: Fallback winner ${session.tickets[session.tickets.length - 1].player.substring(0, 8)} for session ${session.txid}`);
  return session.tickets[session.tickets.length - 1].player;
}
async function updateExpiredSessions(base, now) {
  const sessions = ensureSessionArray(base);
  sessions.forEach(session => {
    if (session.status !== 'OPEN') return;
    if (session.end.isBefore(now)) {
      session.status = session.tickets.length > 0 ? 'CLOSED' : 'SPOILED';
      playSound('expireSound');
      if (session.status === 'CLOSED') {
        session.winner = selectWinner(session);
        logStatus(`Lotto #${base} closed with winner: ${session.winner.substring(0, 8)}`);
      } else if (session.status === 'SPOILED') {
        logStatus(`Lotto #${base} spoiled (no tickets)`);
      }
    }
  });
}

/* ---------------------- Messages fetching & parsing ---------------------- */
async function fetchMasterAddress() {
  try {
    const url = new URL(`${API_BASE}/GetPublicAddressByKeyword/${encodeURIComponent(MASTER_KEYWORD)}`);
    url.searchParams.set('mainnet', String(isMainnet));
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), API_TIMEOUT_MS);
    const res = await fetch(url.toString(), { signal: controller.signal });
    clearTimeout(timeoutId);
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const data = await res.text();
    masterAddress = data.replace(/^"|"$/g, '').trim();
    if (!masterAddress || masterAddress.length < 34 || masterAddress.length > 36) throw new Error(`Invalid master address: ${masterAddress}`);
  } catch (e) {
    masterAddress = null;
  }
}

async function fetchMessages(skip = 0, qty = NORMAL_FETCH_QTY, isInitial = false) {
  if (!masterAddress) {
    await fetchMasterAddress();
    if (!masterAddress) return;
  }
  try {
    const searchState = {
      keyword: $('keyword').value,
      lottoType: $('lottoType').value,
      statusFilter: $('statusFilter').value,
      prizeFilter: $('prizeFilter').value
    };
    const createState = {
      createLottoId: $('createLottoId').value,
      createLottoType: $('createLottoType').value,
      createPrizeModal: $('createPrizeModal').value,
      createQty: $('createQty').value,
      createDuration: $('createDuration').value
    };
    const cleanAddress = masterAddress.replace(/^"|"$/g, '');
    const url = new URL(`${API_BASE}/GetPublicMessagesByAddress/${encodeURIComponent(cleanAddress)}`);
    url.searchParams.set('mainnet', String(isMainnet));
    url.searchParams.set('skip', skip);
    url.searchParams.set('qty', isInitial ? INIT_FETCH_QTY : qty);
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), API_TIMEOUT_MS);
    const res = await fetch(url.toString(), { signal: controller.signal });
    clearTimeout(timeoutId);
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const messages = await res.json();
    if (!Array.isArray(messages)) throw new Error('Invalid response format');
    await analyzeMessages(messages, isInitial);
    $('keyword').value = searchState.keyword;
    $('lottoType').value = searchState.lottoType;
    $('statusFilter').value = searchState.statusFilter;
    $('prizeFilter').value = searchState.prizeFilter;
    $('createLottoId').value = createState.createLottoId;
    $('createLottoType').value = createState.createLottoType;
    $('createPrizeModal').value = createState.createPrizeModal;
    $('createQty').value = createState.createQty;
    $('createDuration').value = createState.createDuration;
  } catch (e) { logError(`fetchMessages error: ${e.message}`); }
}

/* ---------------------- Message parsing helpers ---------------------- */
function extractJsonAndTag(rawMessage) {
  if (!rawMessage) {
    logError('extractJsonAndTag: Empty message');
    return null;
  }
  const jsMatch = rawMessage.match(/{[\s\S]*?}/);
  let tag = null;
  const textLower = rawMessage.toLowerCase();
  if (textLower.includes('#lottocreate')) tag = 'create';
  else if (textLower.includes('#lottoticket') || textLower.includes('#buyticket')) tag = 'ticket';
  const imageMatches = rawMessage.match(/<<([^>]+)>>/g) || [];
  let image = null;
  for (const match of imageMatches) {
    const content = match.replace(/^<<|>>$/g, '');
    logError(`extractJsonAndTag: Processing match: ${content}`);
    if (/^-\d+$/.test(content)) {
      logError(`extractJsonAndTag: Skipping sequence number: ${content}`);
      continue;
    }
    if (content.startsWith('IPFS:') || /^[a-zA-Z0-9]{46}$/.test(content.split('\\')[0])) {
      const hash = content.startsWith('IPFS:') ? content.substring(5).split('\\')[0] : content.split('\\')[0];
      if (/^[a-zA-Z0-9]{46}$/.test(hash)) {
        image = { hash, filename: content.includes('\\') ? content.split('\\').pop() : null, raw: content };
        logError(`extractJsonAndTag: Parsed IPFS hash: ${hash}, filename: ${image.filename}, raw: ${image.raw}`);
        break;
      } else {
        logError(`extractJsonAndTag: Invalid IPFS hash: ${hash}`);
      }
    } else {
      logError(`extractJsonAndTag: Non-IPFS content ignored: ${content}`);
    }
  }
  const message = rawMessage
    .replace(/{[\s\S]*?}/, '')
    .replace(/<<[^>]+>>/g, '')
    .replace(/#LottoCreate|#LottoTicket|#BuyTicket/gi, '')
    .replace(new RegExp(MESSAGE_KEYWORD, 'gi'), '')
    .trim();
  logError(`extractJsonAndTag: Extracted message: ${message}`);
  return { jsonText: jsMatch ? jsMatch[0] : null, tag, image, message: message || null };
}

async function parseMessage(msg) {
  if (!msg || !msg.Message || !msg.Message.toLowerCase().includes(MESSAGE_KEYWORD.toLowerCase())) {
    logError(`parseMessage: Invalid or missing message: ${msg ? msg.Message : 'null'}`);
    return null;
  }
  const extracted = extractJsonAndTag(msg.Message);
  if (!extracted || !extracted.jsonText || !extracted.tag) {
    logError(`parseMessage: Failed to extract JSON or tag from message: ${msg.Message}`);
    return null;
  }
  try {
    const data = JSON.parse(extracted.jsonText);
    const base = normalizeBaseId(data.i || data.I || data.id);
    if (!base) {
      logError(`parseMessage: Invalid base ID from JSON: ${extracted.jsonText}`);
      return null;
    }
    if (extracted.tag === 'create' && (!data.l || !data.p)) {
      logError(`parseMessage: Missing required fields for create: ${extracted.jsonText}`);
      return null;
    }
    const block = moment.utc(msg.BlockDate);
    logError(`parseMessage: Parsed message for base=${base}, tag=${extracted.tag}, txid=${msg.TransactionId}, image=${JSON.stringify(extracted.image)}, message=${extracted.message}`);
    return { kind: extracted.tag, data, base, block, txid: msg.TransactionId, from: msg.FromAddress, image: extracted.image, message: extracted.message };
  } catch (e) {
    logError(`parseMessage: JSON parse error: ${e.message}, jsonText=${extracted.jsonText}`);
    return null;
  }
}

/* ---------------------- Analyze messages and update caches ---------------------- */
async function analyzeMessages(messages, isInitial = false) {
  if (!messages || !messages.length) {
    logError('analyzeMessages: No messages to process');
    return;
  }
  const parsedMessages = (await Promise.all(messages.filter(m => m && m.TransactionId).map(parseMessage))).filter(Boolean).sort((a, b) => a.block.diff(b.block));
  const bases = new Set();
  const addresses = new Set();
  for (const parsed of parsedMessages) {
    if (processedTxIds.has(parsed.txid)) {
      logError(`analyzeMessages: Skipping already processed txid: ${parsed.txid}`);
      continue;
    }
    processedTxIds.add(parsed.txid);
    bases.add(parsed.base);
    addresses.add(parsed.from);
    if (parsed.kind === 'create') {
      await openNewSession(parsed.base, parsed.data, parsed);
      logStatus(`New lotto #${parsed.base} opened`);
      playSound('openSound');
      if (isInitial) playSound('initBeep');
    } else if (parsed.kind === 'ticket') {
      await addTicket(parsed.base, parsed.data, parsed);
      logStatus(`New ticket added to #${parsed.base}`);
      playSound('ticketSound');
    }
  }
  const urnPromises = Array.from(addresses).map(addr => requestQueue.add(() => resolveUserProfileURN(addr)));
  await Promise.all(urnPromises);
  const now = moment.utc();
  bases.forEach(base => updateExpiredSessions(base, now));
  await displayLottos(true);
  updateTypeLists();
  updatePrizeLists();
}

/* ---------------------- Session & Ticket updates ---------------------- */
async function openNewSession(base, data, parsed) {
  const sessions = ensureSessionArray(base);
  const duration = Math.max(1, parseInt(data.d || 1, 10)) * 60;
  const start = parsed.block;
  const bufferedStart = moment.utc(start).subtract(TICKET_BUFFER_MINUTES, 'minutes');
  const end = moment.utc(start).add(duration, 'minutes');
  const prize = (data.p || '').trim();
  const type = (data.l || '').trim().toLowerCase();
  if (prize) cache.prizes.add(prize);
  if (type) cache.types.add(type);
  const session = {
    txid: parsed.txid,
    status: 'OPEN',
    type,
    prize,
    qty: Math.max(1, parseInt(data.q || 1, 10)),
    start,
    bufferedStart,
    end,
    creator: parsed.from,
    winner: null,
    tickets: [],
    image: parsed.image,
    message: parsed.message
  };
  logError(`openNewSession: Created session for base=${base}, txid=${parsed.txid}, image=${JSON.stringify(parsed.image)}, message=${parsed.message}`);
  sessions.push(session);
  sessions.sort((a, b) => b.start.diff(a.start));
  const tickets = ensureTicketArray(base);
  tickets.forEach(t => {
    if (t.block.isSameOrAfter(bufferedStart) && t.block.isSameOrBefore(end)) session.tickets.push(t);
  });
}

async function addTicket(base, data, parsed) {
  const sessions = ensureSessionArray(base);
  const session = sessions.find(s =>
    (s.status === 'OPEN' || s.status === 'SPOILED') &&
    parsed.block.isSameOrAfter(s.bufferedStart) &&
    parsed.block.isSameOrBefore(s.end)
  );
  const tickets = ensureTicketArray(base);
  const ticket = {
    txid: parsed.txid,
    player: parsed.from,
    block: parsed.block,
    message: parsed.message,
    image: parsed.image
  };
  logError(`addTicket: Added ticket for base=${base}, txid=${parsed.txid}, image=${JSON.stringify(parsed.image)}, message=${parsed.message}`);
  tickets.push(ticket);
  tickets.sort((a, b) => b.block.diff(a.block));
  if (!session) return;
  session.tickets.push(ticket);
  if (session.status === 'SPOILED' && session.tickets.length > 0) session.status = 'OPEN';
}

/* ---------------------- IPFS image resolver ---------------------- */
async function resolveIPFSImage(image) {
  if (!image || !image.hash) {
    logError(`resolveIPFSImage: No image or hash provided`);
    return { isImage: false };
  }
  if (cache.imageCache.has(image.hash)) {
    const cached = cache.imageCache.get(image.hash);
    logError(`resolveIPFSImage: Using cached result for ${image.hash}: isImage=${cached.isImage}`);
    return cached;
  }
  const isValidHash = /^[a-zA-Z0-9]{46}$/.test(image.hash);
  if (!isValidHash) {
    cache.imageCache.set(image.hash, { url: null, isImage: false });
    logError(`resolveIPFSImage: Invalid IPFS hash: ${image.hash}`);
    return { isImage: false };
  }
  const extension = image.filename ? `.${image.filename.split('.').pop().toLowerCase()}` : null;
  if (extension && NON_IMAGE_EXTENSIONS.includes(extension)) {
    cache.imageCache.set(image.hash, { url: null, isImage: false });
    logError(`resolveIPFSImage: Non-image extension: ${extension}`);
    return { isImage: false };
  }
  const isImage = !extension || VALID_IMAGE_EXTENSIONS.includes(extension);
  if (!isImage) {
    cache.imageCache.set(image.hash, { url: null, isImage: false });
    logError(`resolveIPFSImage: Not an image: ${image.hash}`);
    return { isImage: false };
  }
  for (let attempt = 1; attempt <= IPFS_RETRY_ATTEMPTS; attempt++) {
    const gateway = IPFS_GATEWAYS[(attempt - 1) % IPFS_GATEWAYS.length];
    const url = `${gateway}${image.hash}`;
    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), API_TIMEOUT_MS);
      const res = await fetch(url, { method: 'HEAD', signal: controller.signal });
      clearTimeout(timeoutId);
      const contentType = res.headers.get('Content-Type') || '';
      const isImageConfirmed = contentType.startsWith('image/') || VALID_IMAGE_EXTENSIONS.includes(extension);
      const result = { url, isImage: isImageConfirmed };
      cache.imageCache.set(image.hash, result);
      logError(`resolveIPFSImage: Resolved ${image.hash} to ${url}, isImage=${isImageConfirmed}, contentType=${contentType}`);
      return result;
    } catch (e) {
      logError(`resolveIPFSImage: Attempt ${attempt} failed for ${url}: ${e.message}`);
      if (attempt === IPFS_RETRY_ATTEMPTS) {
        cache.imageCache.set(image.hash, { url: null, isImage: false });
        logError(`resolveIPFSImage: All attempts failed for ${image.hash}`);
        return { isImage: false };
      }
    }
  }
  return { isImage: false };
}

/* ---------------------- URN/profile resolver ---------------------- */
async function resolveUserProfileURN(address) {
  const now = Date.now();
  const cached = cache.urns.get(address);
  if (cached && now - cached.timestamp < URN_CACHE_TIMEOUT) return { addr: address, profile: { urn: cached.urn, isOfficial: cached.isOfficial } };
  try {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), API_TIMEOUT_MS);
    const addrUrl = new URL(`${API_BASE}/GetProfileByAddress/${encodeURIComponent(address)}`);
    addrUrl.searchParams.set('mainnet', String(isMainnet));
    const addrRes = await fetch(addrUrl.toString(), { signal: controller.signal });
    clearTimeout(timeoutId);
    if (!addrRes.ok) throw new Error(`HTTP ${addrRes.status}`);
    const addrData = await addrRes.json();
    const urn = addrData.URN ? addrData.URN.trim() : null;
    if (!urn) {
      cache.urns.set(address, { urn: null, isOfficial: false, timestamp: now });
      return { addr: address, profile: { urn: null, isOfficial: false } };
    }
    const urnUrl = new URL(`${API_BASE}/GetProfileByURN/${encodeURIComponent(urn)}`);
    urnUrl.searchParams.set('mainnet', String(isMainnet));
    const urnRes = await fetch(urnUrl.toString(), { signal: controller.signal });
    clearTimeout(timeoutId);
    if (!urnRes.ok) throw new Error(`HTTP ${urnRes.status}`);
    const urnData = await urnRes.json();
    const isOfficial = Array.isArray(urnData.Creators) && urnData.Creators.includes(address);
    cache.urns.set(address, { urn, isOfficial, timestamp: now });
    return { addr: address, profile: { urn, isOfficial } };
  } catch (e) {
    cache.urns.set(address, { urn: null, isOfficial: false, timestamp: now });
    return { addr: address, profile: { urn: null, isOfficial: false } };
  }
}

/* ---------------------- UI: displayLottos ---------------------- */
async function displayLottos(updateOnly = false) {
  const now = Date.now();
  if (now - lastDisplayLottos < 1000) {
    logError('displayLottos: Skipping due to debounce');
    return;
  }
  lastDisplayLottos = now;
  const container = $('lottoList');
  if (!container) return;
  const searchState = {
    keyword: $('keyword').value,
    lottoType: $('lottoType').value,
    statusFilter: $('statusFilter').value,
    prizeFilter: $('prizeFilter').value
  };
  const createState = {
    createLottoId: $('createLottoId').value,
    createLottoType: $('createLottoType').value,
    createPrizeModal: $('createPrizeModal').value,
    createQty: $('createQty').value,
    createDuration: $('createDuration').value
  };
  const nowMoment = moment.tz('America/Denver');
  const addresses = new Set();
  cache.sessions.forEach((sessions, base) => {
    sessions.forEach(s => {
      addresses.add(s.creator);
      if (s.winner) addresses.add(s.winner);
      s.tickets.forEach(t => addresses.add(t.player));
    });
  });
  const urnPromises = Array.from(addresses).map(addr => requestQueue.add(() => resolveUserProfileURN(addr)));
  const urnResults = await Promise.all(urnPromises);
  const urnMap = new Map(urnResults.map(r => [r.addr, r.profile]));
  const sessionCards = [];
  cache.sessions.forEach((sessions, base) => {
    sessions.forEach(session => {
      if (searchState.keyword && !base.toLowerCase().includes(searchState.keyword.toLowerCase())) return;
      if (searchState.lottoType && session.type !== searchState.lottoType) return;
      if (searchState.prizeFilter && session.prize !== searchState.prizeFilter) return;
      if (session.status === 'OPEN' && session.end.isBefore(nowMoment)) {
        session.status = session.tickets.length > 0 ? 'CLOSED' : 'SPOILED';
        playSound('expireSound');
        if (session.status === 'CLOSED') {
          session.winner = selectWinner(session);
          logStatus(`Lotto #${base} closed with winner: ${session.winner.substring(0, 8)}`);
        } else if (session.status === 'SPOILED') {
          logStatus(`Lotto #${base} spoiled (no tickets)`);
        }
      }
      if (searchState.statusFilter && session.status !== searchState.statusFilter) return;
      sessionCards.push({ base, session });
    });
  });
  sessionCards.sort((a, b) => b.session.start.diff(a.session.start));
  const frag = document.createDocumentFragment();
  for (const sc of sessionCards) {
    const base = sc.base;
    const session = sc.session;
    const totalTickets = session.tickets.length;
    const allTickets = (cache.tickets.get(base) || []).length;
    const creatorProfile = urnMap.get(session.creator) || { urn: null, isOfficial: false };
    const creatorDisplay = creatorProfile.urn || session.creator.substring(0, 8);
    const creatorClass = creatorProfile.isOfficial || !creatorProfile.urn ? '' : 'non-official';
    const winnerProfile = session.winner ? (urnMap.get(session.winner) || { urn: null, isOfficial: false }) : null;
    const winnerDisplay = winnerProfile ? (winnerProfile.urn || session.winner.substring(0, 8)) : null;
    let imageData = session.image ? cache.imageCache.get(session.image.hash) || null : null;
    logError(`displayLottos: Processing card for base=${base}, txid=${session.txid}, hasImage=${!!session.image}, imageData=${JSON.stringify(imageData)}, message=${session.message}`);
    const card = document.createElement('div');
    card.className = `lotto-card ${session.status === 'OPEN' ? 'open' : 'closed'}${session.winner ? ' winner' : ''}`;
    card.dataset.base = base;
    card.dataset.txid = session.txid || '';
    const statusBadge = session.status === 'SPOILED' ? `<span class="spoiled-badge">SPOILED</span>` : `<span class="card-badge">${session.status}</span>`;
    let imgTag = '';
    if (session.image && session.image.hash) {
      imgTag = `<div class="image-container">`;
      if (imageData && imageData.isImage) {
        imgTag += `<img src="${imageData.url}" class="lotto-image" alt="lotto image">`;
      }
      if (session.winner) imgTag += `<div class="winner-highlight">Winner: ${winnerDisplay} üèÜ</div>`;
      imgTag += `</div>`;
    }
    let html = `
      <div class="card-top">
        <div style="flex:1"><strong>#${base}</strong><div style="font-size:11px;color:#80cc99">${session.type || 'Unknown'} ‚Ä¢ ${session.prize || '‚Äî'}</div></div>
        ${statusBadge}
      </div>
      <div class="lotto-meta">
        Qty: ${session.qty} ‚Ä¢ SessionTickets: ${totalTickets} ‚Ä¢ AllTickets: ${allTickets}<br>
        Open: ${session.start.format('YYYY-MM-DD HH:mm')}<br>
        Close: ${session.end.format('YYYY-MM-DD HH:mm')}<br>
        Tx: ${session.txid.substring(0, 8)}...<br>
        Creator: <a href="#" class="${creatorClass}" data-addr="${session.creator}">${creatorDisplay}</a>
        ${winnerDisplay ? `<br>Winner: <a href="#" data-addr="${session.winner}">${winnerDisplay} üèÜ</a>` : ''}
      </div>
    `;
    if (session.message) html += `<div class="lotto-message">${session.message.length > 30 ? session.message.substring(0, 30) + '...' : session.message}</div>`;
    html += imgTag;
    if (session.status === 'OPEN') html += `<button data-action="buy" data-base="${base}">üöÄ BUY</button>`;
    card.innerHTML = html;
    if (session.image && session.image.hash && (!imageData || !imageData.isImage)) {
      logError(`displayLottos: Queueing IPFS fetch for ${session.image.hash}`);
      imageFetchQueue.add(() => resolveIPFSImage(session.image)).then(imgData => {
        if (imgData && imgData.isImage) {
          logError(`displayLottos: IPFS resolved for ${session.image.hash}, updating card`);
          cache.imageCache.set(session.image.hash, imgData);
          const existingImg = card.querySelector('.lotto-image');
          if (!existingImg) {
            const container = card.querySelector('.image-container') || card;
            const img = document.createElement('img');
            img.src = imgData.url;
            img.className = 'lotto-image';
            img.alt = 'lotto image';
            if (container.className === 'image-container') {
              container.insertBefore(img, container.firstChild);
            } else {
              container.appendChild(img);
            }
          }
        }
      }).catch(e => logError(`displayLottos: IPFS fetch failed for ${session.image.hash}: ${e.message}`));
    }
    card.addEventListener('click', (ev) => {
      const target = ev.target;
      if (target && target.dataset && target.dataset.action === 'buy') {
        ev.stopPropagation();
        showCopyModal('ticket', base);
        return;
      }
      const txid = card.dataset.txid || '';
      showTicketModal(base, txid);
    });
    frag.appendChild(card);
  }
  container.innerHTML = '';
  container.appendChild(frag);
  $('keyword').value = searchState.keyword;
  $('lottoType').value = searchState.lottoType;
  $('statusFilter').value = searchState.statusFilter;
  $('prizeFilter').value = searchState.prizeFilter;
  $('createLottoId').value = createState.createLottoId;
  $('createLottoType').value = createState.createLottoType;
  $('createPrizeModal').value = createState.createPrizeModal;
  $('createQty').value = createState.createQty;
  $('createDuration').value = createState.createDuration;
}

/* ---------------------- showTicketModal ---------------------- */
async function showTicketModal(base, txid) {
  base = base || '';
  txid = txid || '';
  const overlay = $('ticketOverlay');
  const thread = $('ticketThread');
  if (!overlay || !thread) return;
  thread.innerHTML = '';
  const sessions = cache.sessions.get(base) || [];
  const session = sessions.find(s => (s.txid || '') === txid);
  if (!session) {
    const fallback = sessions[0];
    if (!fallback) {
      const noEntry = document.createElement('div');
      noEntry.className = 'ticket-entry';
      noEntry.textContent = 'No session found.';
      thread.appendChild(noEntry);
      overlay.style.display = 'flex';
      return;
    }
    txid = fallback.txid;
  }
  const sess = session || sessions[0];
  const tickets = sess.tickets || [];
  if (!tickets.length) {
    const noEntry = document.createElement('div');
    noEntry.className = 'ticket-entry';
    noEntry.textContent = 'No tickets found.';
    thread.appendChild(noEntry);
    overlay.style.display = 'flex';
    return;
  }
  const seen = new Set();
  const uniqueTickets = tickets.filter(t => {
    if (seen.has(t.txid)) return false;
    seen.add(t.txid);
    return true;
  });
  const addresses = new Set(uniqueTickets.map(t => t.player));
  const urnPromises = Array.from(addresses).map(addr => requestQueue.add(() => resolveUserProfileURN(addr)));
  const urnResults = await Promise.all(urnPromises);
  const urnMap = new Map(urnResults.map(r => [r.addr, r.profile]));
  const renderBatch = async (start, limit) => {
    const end = Math.min(start + limit, uniqueTickets.length);
    const frag = document.createDocumentFragment();
    for (let i = start; i < end; i++) {
      const ticket = uniqueTickets[i];
      const playerProfile = urnMap.get(ticket.player) || { urn: null, isOfficial: false };
      const playerDisplay = playerProfile.urn || (ticket.player ? ticket.player.substring(0, 8) : 'unknown');
      const playerClass = playerProfile.isOfficial || !playerProfile.urn ? '' : 'non-official';
      const isWinner = sess.winner && sess.winner === ticket.player;
      const entry = document.createElement('div');
      entry.className = `ticket-entry${isWinner ? ' winner' : ''}`;
      entry.dataset.txid = ticket.txid || '';
      entry.dataset.index = i;
      let inner = `<div><strong>Player:</strong> <a href="#" class="${playerClass}" data-addr="${ticket.player}">${playerDisplay}</a></div>`;
      inner += `<div><strong>Time:</strong> ${ticket.block ? ticket.block.format('YYYY-MM-DD HH:mm') : '‚Äî'}</div>`;
      inner += `<div><strong>TxID:</strong> ${ticket.txid ? ticket.txid.substring(0, 8) + '...' : '‚Äî'}</div>`;
      if (ticket.message) inner += `<div style="margin-top:6px;color:#b3ccbb">${ticket.message.length > 250 ? ticket.message.substring(0, 250) + '...' : ticket.message}</div>`;
      entry.innerHTML = inner;
      if (ticket.image && ticket.image.hash) {
        const cached = cache.imageCache.get(ticket.image.hash);
        logError(`showTicketModal: Processing ticket txid=${ticket.txid}, hasImage=${!!ticket.image}, cached=${JSON.stringify(cached)}, message=${ticket.message}`);
        if (cached && cached.isImage) {
          const img = document.createElement('img');
          img.src = cached.url;
          img.className = 'ticket-image';
          img.alt = 'ticket image';
          entry.appendChild(img);
        } else {
          imageFetchQueue.add(() => resolveIPFSImage(ticket.image)).then(imgData => {
            if (imgData && imgData.isImage) {
              logError(`showTicketModal: IPFS resolved for ${ticket.image.hash}, updating ticket`);
              cache.imageCache.set(ticket.image.hash, imgData);
              const img = document.createElement('img');
              img.src = imgData.url;
              img.className = 'ticket-image';
              img.alt = 'ticket image';
              entry.appendChild(img);
            }
          }).catch(e => logError(`showTicketModal: IPFS fetch failed for ${ticket.image.hash}: ${e.message}`));
        }
      }
      frag.appendChild(entry);
    }
    thread.appendChild(frag);
  };
  await renderBatch(0, INITIAL_TICKET_RENDER_LIMIT);
  if (uniqueTickets.length > INITIAL_TICKET_RENDER_LIMIT) {
    if (ticketObserver) {
      ticketObserver.disconnect();
      ticketObserver = null;
    }
    ticketObserver = new IntersectionObserver(async (entries, obs) => {
      for (const e of entries) {
        if (e.isIntersecting) {
          const last = thread.lastElementChild;
          if (!last) {
            obs.disconnect();
            return;
          }
          const lastIndex = parseInt(last.dataset.index || (thread.children.length - 1), 10);
          if (lastIndex + 1 < uniqueTickets.length) {
            await renderBatch(lastIndex + 1, INITIAL_TICKET_RENDER_LIMIT);
          } else {
            obs.disconnect();
          }
        }
      }
    }, { root: thread, threshold: 0.1 });
    ticketObserver.observe(thread.lastElementChild);
  }
  overlay.style.display = 'flex';
}

/* ---------------------- Close ticket modal ---------------------- */
function closeTicketModal() {
  const overlay = $('ticketOverlay');
  if (ticketObserver) {
    ticketObserver.disconnect();
    ticketObserver = null;
  }
  if (overlay) overlay.style.display = 'none';
}

/* ---------------------- Copy/Create modal helpers ---------------------- */
function showCreateModal() {
  $('createLottoId').value = $('keyword').value || '';
  $('createLottoType').value = $('lottoType').value || '';
  $('createPrizeModal').value = $('prizeFilter').value || '';
  $('createModalOverlay').style.display = 'flex';
}
function closeCreateModal() {
  $('createModalOverlay').style.display = 'none';
}
function showCopyModal(mode, base = '') {
  const copyModal = $('copyModalOverlay');
  const copyScript = $('copyScript');
  let script = '';
  if (mode === 'create') {
    const keyword = normalizeBaseId($('createLottoId').value);
    const type = $('createLottoType').value.trim();
    const prize = $('createPrizeModal').value.trim();
    const qty = parseInt($('createQty').value || 1, 10);
    const duration = parseInt($('createDuration').value || 1, 10);
    if (!keyword || !type || !prize) return;
    script = `{"i":" #${keyword} ","l":"${type}","p":"${prize}","q":${qty},"d":${duration}} #LottoCreate ${MESSAGE_KEYWORD} `;
    closeCreateModal();
  } else if (mode === 'ticket') {
    script = `{"i":" #${base} "} #LottoTicket ${MESSAGE_KEYWORD} `;
  }
  copyScript.value = script;
  copyModal.style.display = 'flex';
}
function copyToClipboard() {
  const copyScript = $('copyScript');
  copyScript.select();
  document.execCommand('copy');
  closeCopyModal();
}
function closeCopyModal() {
  $('copyModalOverlay').style.display = 'none';
}

/* ---------------------- Prize and Type list updaters ---------------------- */
function updatePrizeLists() {
  const prizeFilter = $('prizeFilter');
  const prizeOptions = $('prizeOptions');
  const selectedPrizeFilter = prizeFilter.value;
  const selectedPrizeModal = $('createPrizeModal').value;
  prizeFilter.innerHTML = '<option value="">Any Prize</option>';
  prizeOptions.innerHTML = '';
  Array.from(cache.prizes).sort().forEach(prize => {
    const o1 = document.createElement('option');
    o1.value = prize;
    o1.textContent = prize;
    prizeFilter.appendChild(o1);
    const o2 = document.createElement('option');
    o2.value = prize;
    prizeOptions.appendChild(o2);
  });
  prizeFilter.value = selectedPrizeFilter;
  $('createPrizeModal').value = selectedPrizeModal;
}

function updateTypeLists() {
  const lottoType = $('lottoType');
  const createLottoType = $('createLottoType');
  const selectedLottoType = lottoType.value;
  const selectedCreateLottoType = createLottoType.value;
  lottoType.innerHTML = '<option value="">Any Type</option>';
  createLottoType.innerHTML = '<option value="">Select Type</option>';
  Array.from(cache.types).sort().forEach(type => {
    const o1 = document.createElement('option');
    o1.value = type;
    o1.textContent = type.toUpperCase();
    lottoType.appendChild(o1);
    const o2 = document.createElement('option');
    o2.value = type;
    o2.textContent = type.toUpperCase();
    createLottoType.appendChild(o2);
  });
  lottoType.value = selectedLottoType;
  createLottoType.value = selectedCreateLottoType;
}

/* ---------------------- Initialize (boot + poll) ---------------------- */
function init() {
  $('scanBtn').addEventListener('click', () => displayLottos(false));
  $('createBtn').addEventListener('click', showCreateModal);
  $('createCancelBtn').addEventListener('click', closeCreateModal);
  $('createSubmitBtn').addEventListener('click', () => showCopyModal('create'));
  $('copyCloseBtn').addEventListener('click', closeCopyModal);
  $('copyBtn').addEventListener('click', copyToClipboard);
  $('ticketCloseBtn').addEventListener('click', closeTicketModal);
  updateTypeLists();
  updatePrizeLists();
  fetchMasterAddress().then(() => {
    if (masterAddress) fetchMessages(0, INIT_FETCH_QTY, true);
  });
  setInterval(() => fetchMessages(), POLL_MS);
}
init();
</script>
</body>
</html>