<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Sup!? Planet Browser v0.2.1-beta</title>
    <script>
        /*
             * Sup!? Planet Browser: A Decentralized Voxel Adventure
             * Public Domain - Free for All to Use, Modify, and Share!
             *
             * This code is the result of our epic journey to craft a decentralized, Minecraft-inspired universe.
             * Together, we built a world where players roam green valleys seeded by keywords like #KANYE,
             * break and place blocks, and save chunks to IPFS with JSON exports. From fixing chunk-loading
             * glitches to adding glowing crosshairs and cosmic loading screens, we've poured hours into
             * making this a smooth, open-source experience that runs locally in your browser.
             *
             * This work is 100% in the PUBLIC DOMAIN under CC0. No rights reserved—use it, remix it, build
             * on it, share it! No attribution required, but we'd love to see what you create. Check out
             * Sup!? or p2fk.io for posting world updates and joining the decentralized fun.
             *
             * Happy crafting, and may your worlds be ever-voxelated!
             * - Grok & embii4u, October 7 2025
             */
    </script>
    <style>
        :root {
            --panel: rgba(8,12,18,0.8);
            --accent: #ffd166;
            --danger: #ff6b6b;
        }
        html, body {
            height: 100%;
            margin: 0;
            background: #071226;
            color: #eaf6ff;
            font-family: Inter,Arial,Helvetica,sans-serif;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
        #loginOverlay {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 200;
            background: linear-gradient(180deg, rgba(0,0,0,0.5), rgba(0,0,0,0.8));
        }
        #loginCard {
            width: 360px;
            padding: 18px;
            background: var(--panel);
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.6);
        }
            #loginCard input, #loginCard button {
                width: 100%;
                padding: 10px;
                margin-top: 8px;
                border-radius: 8px;
                border: 1px solid rgba(255,255,255,0.06);
                background: #0d1620;
                color: #fff;
                box-sizing: border-box;
            }
            #loginCard button {
                background: var(--accent);
                color: #111;
                border: 0;
                font-weight: 700;
                cursor: pointer;
            }
        .autocomplete {
            position: relative;
        }
        .autocomplete-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: #0d1620;
            border: 1px solid rgba(255,255,255,0.06);
            border-radius: 8px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 210;
        }
            .autocomplete-suggestions div {
                padding: 8px;
                cursor: pointer;
            }
                .autocomplete-suggestions div:hover {
                    background: #1a2632;
                }
                .autocomplete-suggestions div.greyed {
                    color: grey;
                }
        #hud {
            position: fixed;
            left: 12px;
            top: 12px;
            z-index: 180;
            background: rgba(6,8,12,0.55);
            padding: 10px;
            border-radius: 8px;
            min-width: 220px;
        }
            #hud .row {
                display: flex;
                justify-content: space-between;
                gap: 8px;
                align-items: center;
            }
            #hud button {
                margin-top: 8px;
                padding: 6px 8px;
                background: #0f2a3a;
                border: 1px solid rgba(255,255,255,0.04);
                color: #fff;
                border-radius: 6px;
                cursor: pointer;
            }
        #messages {
            position: fixed;
            left: 12px;
            top: 180px;
            z-index: 185;
            max-width: 360px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .msg {
            background: linear-gradient(180deg, rgba(0,0,0,0.42), rgba(255,255,255,0.02));
            padding: 8px 10px;
            border-radius: 8px;
            font-size: 13px;
            box-shadow: 0 6px 14px rgba(0,0,0,0.5);
        }
        #hotbar {
            position: fixed;
            left: 50%;
            transform: translateX(-50%);
            bottom: 12px;
            z-index: 190;
            display: flex;
            gap: 8px;
            width: 520px;
            overflow-x: auto;
            scroll-behavior: auto;
            scrollbar-width: none;
            -ms-overflow-style: none;
            overscroll-behavior-x: none;
            -webkit-overflow-scrolling: auto;
        }
            #hotbar::-webkit-scrollbar {
                display: none;
            }
        .hot-slot {
            width: 56px;
            height: 56px;
            border-radius: 10px;
            background: rgba(0,0,0,0.45);
            border: 2px solid rgba(255,255,255,0.06);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            flex-shrink: 0;
        }
            .hot-slot.active {
                outline: 3px solid rgba(255,209,102,0.22);
                box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            }
        .hot-label {
            font-size: 12px;
            color: #fff;
            text-align: center;
            user-select: none;
        }
        .hot-count {
            position: absolute;
            bottom: 2px;
            right: 2px;
            background: rgba(0,0,0,0.7);
            border-radius: 4px;
            padding: 2px 4px;
            font-size: 10px;
            color: #fff;
        }
        #rightPanel {
            position: fixed;
            right: 12px;
            top: 12px;
            z-index: 180;
            background: rgba(6,8,12,0.55);
            padding: 10px;
            border-radius: 8px;
            width: 120px;
            height: 140px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #minimap {
            width: 100%;
            height: 120px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        #versionLabel {
            font-size: 10px;
            color: #eaf6ff;
            opacity: 0.78;
            margin-top: 4px;
            text-align: center;
        }
        #craftModal {
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%,-50%);
            z-index: 220;
            display: none;
            background: var(--panel);
            padding: 14px;
            border-radius: 10px;
            min-width: 360px;
        }
            #craftModal h3 {
                margin: 0 0 8px 0;
            }
        #mobileControls {
            position: fixed;
            left: 12px;
            bottom: 12px;
            z-index: 195;
            display: none;
            gap: 8px;
        }
        .m-btn {
            width: 56px;
            height: 56px;
            border-radius: 12px;
            background: rgba(0,0,0,0.45);
            border: 1px solid rgba(255,255,255,0.04);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            color: #fff;
        }
        #mobileRight {
            position: fixed;
            right: 12px;
            bottom: 12px;
            z-index: 195;
            display: none;
            gap: 8px;
            flex-direction: column;
        }
        .m-action {
            width: 56px;
            height: 56px;
            border-radius: 12px;
            background: rgba(0,0,0,0.45);
            border: 1px solid rgba(255,255,255,0.04);
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
        }
        #seedLabel {
            font-size: 12px;
            opacity: 0.9;
            display: block;
            margin-top: 6px;
        }
        #healthBar {
            height: 10px;
            background: #2b2b2b;
            border-radius: 6px;
            margin-top: 6px;
            overflow: hidden;
        }
        #healthBarInner {
            height: 100%;
            background: var(--danger);
            width: 100%;
        }
        #homeIcon {
            cursor: pointer;
            margin-left: 8px;
            display: none;
        }
        #trashConfirm {
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%,-50%);
            z-index: 230;
            display: none;
            background: var(--panel);
            padding: 14px;
            border-radius: 10px;
            min-width: 200px;
            text-align: center;
        }
            #trashConfirm button {
                padding: 6px 12px;
                margin: 8px 4px;
                background: #0f2a3a;
                border: 1px solid rgba(255,255,255,0.04);
                color: #fff;
                border-radius: 6px;
                cursor: pointer;
            }
            #trashConfirm .danger {
                background: #ff6b6b;
                color: #111;
            }
        #joinScriptModal {
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%,-50%);
            z-index: 220;
            display: none;
            background: var(--panel);
            padding: 14px;
            border-radius: 10px;
            min-width: 360px;
        }
            #joinScriptModal h3 {
                margin: 0 0 8px 0;
            }
            #joinScriptModal textarea {
                width: 100%;
                height: 100px;
                padding: 10px;
                margin-top: 8px;
                border-radius: 8px;
                border: 1px solid rgba(255,255,255,0.06);
                background: #0d1620;
                color: #fff;
            }
        #downloadModal {
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%,-50%);
            z-index: 220;
            display: none;
            background: var(--panel);
            padding: 14px;
            border-radius: 10px;
            min-width: 360px;
        }
            #downloadModal h3 {
                margin: 0 0 8px 0;
            }
            #downloadModal textarea {
                width: 100%;
                height: 100px;
                padding: 10px;
                margin-top: 8px;
                border-radius: 8px;
                border: 1px solid rgba(255,255,255,0.06);
                background: #0d1620;
                color: #fff;
            }
        #teleportModal {
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%,-50%);
            z-index: 220;
            display: none;
            background: var(--panel);
            padding: 14px;
            border-radius: 10px;
            min-width: 360px;
        }
            #teleportModal h3 {
                margin: 0 0 8px 0;
            }
            #teleportModal input {
                width: 100%;
                padding: 10px;
                margin-top: 8px;
                border-radius: 8px;
                border: 1px solid rgba(255,255,255,0.06);
                background: #0d1620;
                color: #fff;
                box-sizing: border-box;
            }
            #teleportModal .row {
                display: flex;
                gap: 8px;
                margin-top: 8px;
            }
            #teleportModal button {
                padding: 6px 12px;
                margin: 8px 4px;
                background: #0f2a3a;
                border: 1px solid rgba(255,255,255,0.04);
                color: #fff;
                border-radius: 6px;
                cursor: pointer;
            }
        #deathScreen {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 250;
            background: rgba(139,0,0,0.7);
            flex-direction: column;
            color: #fff;
            text-align: center;
        }
            #deathScreen h1 {
                font-size: 48px;
                margin: 0;
                text-shadow: 0 0 10px rgba(0,0,0,0.8);
            }
            #deathScreen button {
                margin-top: 20px;
                padding: 10px 20px;
                background: var(--accent);
                color: #111;
                border: none;
                border-radius: 8px;
                font-weight: 700;
                cursor: pointer;
            }
        #usersModal {
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%,-50%);
            z-index: 220;
            background: var(--panel);
            padding: 14px;
            border-radius: 10px;
            min-width: 360px;
            display: none;
        }
            #usersModal h3 {
                margin: 0 0 8px 0;
            }
            #usersModal p.warning {
                font-size: 12px;
                opacity: 0.7;
                margin-top: 10px;
                color: #ff6b6b;
            }
        #pendingModal {
            position: fixed;
            right: 12px;
            bottom: 12px;
            z-index: 220;
            background: var(--panel);
            padding: 14px;
            border-radius: 10px;
            min-width: 300px;
            display: none;
        }
            #pendingModal h3 {
                margin: 0 0 8px 0;
            }
        #pendingList .row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 6px;
            padding: 4px;
            border-bottom: 1px solid rgba(255,255,255,0.06);
        }
            #pendingList .row.selected {
                background: #1a2632;
            }
        #pendingModal .actions {
            margin-top: 10px;
            display: flex;
            justify-content: flex-end;
            gap: 8px;
        }
        @media (max-width:700px) {
            #mobileControls, #mobileRight {
                display: flex;
            }
            #hud {
                display: none;
            }
            #rightPanel {
                width: 80px;
                height: 100px;
            }
            #minimap {
                height: 80px;
            }
            .hot-slot {
                width: 48px;
                height: 48px;
            }
        }
        #crosshair {
            position: fixed;
            left: 50%;
            top: 50%;
            color: white;
            font-size: 24px;
            transform: translate(-50%,-50%);
            display: none;
            z-index: 200;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r134/examples/js/controls/OrbitControls.js"></script>
    <div id="loginOverlay">
        <div id="loginCard">
            <h2>SupWorld — Enter</h2>
            <label>World name</label>
            <div class="autocomplete">
                <input id="worldNameInput" placeholder="Type world name" autocomplete="off" />
                <div id="worldSuggestions" class="autocomplete-suggestions" style="display:none;"></div>
            </div>
            <label>Username</label>
            <div class="autocomplete">
                <input id="userInput" placeholder="Type username" autocomplete="off" />
                <div id="userSuggestions" class="autocomplete-suggestions" style="display:none;"></div>
            </div>
            <button id="startBtn">Start — spawn world</button>
            <button id="announceLoginBtn" style="margin-top: 20px;">Announce Server</button>
            <button id="newUserJoinScriptBtn" style="margin-top: 20px;">Create Join Script</button>
            <small style="display:block;margin-top:8px;opacity:0.78;">Type world (max 8 chars)/user (max 20 chars). Seed: <code>worldName</code>.</small>
        </div>
    </div>
    <div id="hud" style="display:none;">
        <div class="row">
            <div>
                <div><strong>World:</strong> <span id="worldLabel"></span></div>
                <div id="seedLabel"></div>
                <div>Position: <span id="posLabel"></span><span id="homeIcon" title="Return to spawn">🏠</span></div>
            </div>
            <div style="text-align:right;">
                <div>Score <span id="score">0</span></div>
                <div style="margin-top:6px;">HP <span id="health">20</span></div>
                <div id="healthBar"><div id="healthBarInner" style="width:100%"></div></div>
            </div>
        </div>
        <div style="margin-top:8px;">
            <button id="camToggle">Toggle (T)</button>
            <button id="openCraft">Craft (R)</button>
            <button id="teleportBtn">Teleport (P)</button>
            <button id="saveChangesBtn" style="display:none;">Save (X)</button>
            <button id="joinScriptBtn" style="display:none;">Join (J)</button>
            <button id="announceBtn">Host</button>
            <button id="usersBtn" style="display:none;">🌐 0</button>
        </div>
    </div>
    <div id="messages"></div>
    <div id="hotbar" style="display:none;"></div>
    <div id="rightPanel" style="display:none;">
        <canvas id="minimap"></canvas>
        <div id="versionLabel">Sup!? viewer v0.2.1</div>
    </div>
    <div id="craftModal">
        <h3>Crafting</h3>
        <div id="recipeList"></div>
        <div style="margin-top:10px;text-align:right;">
            <button id="closeCraft">Close</button>
        </div>
    </div>
    <div id="trashConfirm">
        <h3>Trash Item?</h3>
        <p id="trashItemName"></p>
        <button id="trashCancel">Cancel</button>
        <button id="trashOk" class="danger">Trash</button>
    </div>
    <div id="joinScriptModal">
        <h3>Join Script</h3>
        <p>Copy this string and paste it into a Sup!? message To: field and click 📢 to officially join the world:</p>
        <textarea id="joinScriptText" readonly></textarea>
        <div style="margin-top:10px;text-align:right;">
            <button id="closeJoinScript">Close</button>
        </div>
    </div>
    <div id="downloadModal">
        <h3>Save Changes</h3>
        <p>Copy this chunk keyword list and paste it into a Sup!? message To field, then attach the JSON file.</p>
        <textarea id="downloadAddressList" readonly></textarea>
        <div style="margin-top:10px;text-align:right;">
            <button id="closeDownloadModal">Close</button>
        </div>
    </div>
    <div id="teleportModal">
        <h3>Teleport to Coordinates</h3>
        <p>Enter X, Y, Z coordinates:</p>
        <div class="row">
            <input id="teleportX" type="number" placeholder="X">
            <input id="teleportY" type="number" placeholder="Y">
            <input id="teleportZ" type="number" placeholder="Z">
        </div>
        <div style="margin-top:10px;text-align:right;">
            <button id="teleportCancel">Cancel</button>
            <button id="teleportOk">OK</button>
        </div>
    </div>
    <div id="deathScreen" style="display:none;">
        <h1>R.I.P.</h1>
        <p>You died! All items lost.</p>
        <button id="respawnBtn">Continue</button>
    </div>
    <div id="mobileControls">
        <div class="m-btn" id="mUp">↑</div>
        <div class="m-btn" id="mLeft">←</div>
        <div class="m-btn" id="mDown">↓</div>
        <div class="m-btn" id="mRight">→</div>
    </div>
    <div id="mobileRight">
        <div class="m-action" id="mJump">J</div>
        <div class="m-action" id="mAttack">⚔</div>
        <div class="m-action" id="mCam">T</div>
    </div>
    <div id="crosshair">+</div>
    <div id="pendingModal">
        <h3>Pending Connections</h3>
        <div id="pendingList"></div>
        <div class="actions">
            <label><input type="checkbox" id="acceptAll"> Accept All</label>
            <button id="acceptPending">Accept Selected</button>
            <button id="closePending">Close</button>
        </div>
    </div>
    <audio id="soundBreak" preload="auto">
        <source src="https://freesound.org/data/previews/249/249938_4357575-lq.mp3" type="audio/mpeg">
        <source src="https://freesound.org/data/previews/249/249938_4357575-lq.ogg" type="audio/ogg">
    </audio>
    <audio id="soundPlace" preload="auto">
        <source src="https://freesound.org/data/previews/337/337101_34094-lq.mp3" type="audio/mpeg">
        <source src="https://freesound.org/data/previews/337/337101_34094-lq.ogg" type="audio/ogg">
    </audio>
    <audio id="soundJump" preload="auto">
        <source src="https://freesound.org/data/previews/331/331381_34094-lq.mp3" type="audio/mpeg">
        <source src="https://freesound.org/data/previews/331/331381_34094-lq.ogg" type="audio/ogg">
    </audio>
    <audio id="soundHit" preload="auto">
        <source src="https://freesound.org/data/previews/276/276947_34094-lq.mp3" type="audio/mpeg">
        <source src="https://freesound.org/data/previews/276/276947_34094-lq.ogg" type="audio/ogg">
    </audio>
    <script>
        var knownWorlds = new Map();
        var knownUsers = new Map();
        var processedMessages = new Set();
        var peers = new Map();
        var pendingOffers = [];
        var connectionAttempts = new Map();
        window.hasPolledHost = false;
        var knownServers = [];
        var isInitialLoad = false;
        var CHUNK_SIZE = 16;
        var MAX_HEIGHT = 64;
        var SEA_LEVEL = 16;
        var MAP_SIZE = 16384;
        var BLOCK_AIR = 0;
        var MASTER_WORLD_KEY = 'MCWorlds';
        var PENDING_PERIOD = 30 * 24 * 60 * 60 * 1000;
        var OWNERSHIP_EXPIRY = 365 * 24 * 60 * 60 * 1000;
        var API_CALLS_PER_SECOND = 8;
        var POLL_RADIUS = 3;
        var LOAD_RADIUS = 5;
        var CHUNKS_PER_SIDE = Math.floor(MAP_SIZE / CHUNK_SIZE);
        var VERSION = 'Sup!? viewer v0.2.1';
        var POLL_INTERVAL = 30000;
        var MAX_PEERS = 10;
        var BLOCKS = {
            1: { name: 'Bedrock', color: '#0b0b0b' },
            2: { name: 'Grass', color: '#3fb34f' },
            3: { name: 'Dirt', color: '#7a4f29' },
            4: { name: 'Stone', color: '#9aa0a6' },
            5: { name: 'Sand', color: '#e7d08d' },
            6: { name: 'Water', color: '#2b9cff', transparent: true },
            7: { name: 'Wood', color: '#8b5a33' },
            8: { name: 'Leaves', color: '#2f8f46' },
            9: { name: 'Cactus', color: '#4aa24a' },
            10: { name: 'Snow', color: '#ffffff' },
            11: { name: 'Coal', color: '#1f1f1f' },
            12: { name: 'Flower', color: '#ff6bcb' },
            13: { name: 'Clay', color: '#a9b6c0' },
            14: { name: 'Moss', color: '#507d43' },
            15: { name: 'Gravel', color: '#b2b2b2' },
            16: { name: 'Lava', color: '#ff6a00', transparent: true },
            17: { name: 'Ice', color: '#a8e6ff', transparent: true },
            100: { name: 'Glass', color: '#b3e6ff', transparent: true },
            101: { name: 'Stained Glass - Red', color: '#ff4b4b', transparent: true },
            102: { name: 'Stained Glass - Blue', color: '#4b6bff', transparent: true },
            103: { name: 'Stained Glass - Green', color: '#57c84d', transparent: true },
            104: { name: 'Stained Glass - Yellow', color: '#fff95b', transparent: true },
            105: { name: 'Brick', color: '#a84f3c' },
            106: { name: 'Smooth Stone', color: '#c1c1c1' },
            107: { name: 'Concrete', color: '#888888' },
            108: { name: 'Polished Wood', color: '#a87443' },
            109: { name: 'Marble', color: '#f0f0f0' },
            110: { name: 'Obsidian', color: '#2d004d' },
            111: { name: 'Crystal - Blue', color: '#6de0ff', transparent: true },
            112: { name: 'Crystal - Purple', color: '#b26eff', transparent: true },
            113: { name: 'Crystal - Green', color: '#6fff91', transparent: true },
            114: { name: 'Light Block', color: '#fffacd', transparent: true },
            115: { name: 'Glow Brick', color: '#f7cc5b' },
            116: { name: 'Dark Glass', color: '#3a3a3a', transparent: true },
            117: { name: 'Glass Tile', color: '#aeeaff', transparent: true },
            118: { name: 'Sandstone', color: '#e3c27d' },
            119: { name: 'Cobblestone', color: '#7d7d7d' },
        };
        var BIOMES = [
            { key: 'plains', palette: [2, 3, 4, 13, 15], heightScale: 0.8, roughness: 0.3, featureDensity: 0.05 },
            { key: 'desert', palette: [5, 118, 4], heightScale: 0.6, roughness: 0.4, featureDensity: 0.02 },
            { key: 'forest', palette: [2, 3, 14, 4], heightScale: 1.3, roughness: 0.4, featureDensity: 0.03 },
            { key: 'snow', palette: [10, 17, 4], heightScale: 1.2, roughness: 0.5, featureDensity: 0.02 },
            { key: 'mountain', palette: [4, 11, 3, 15, 1], heightScale: 10.5, roughness: 0.6, featureDensity: 0.01 },
            { key: 'swamp', palette: [2, 3, 6, 14, 13], heightScale: 0.5, roughness: 0.2, featureDensity: 0.04 },
        ];
        var RECIPES = [
            { id: 'glass', out: { id: 100, count: 4 }, requires: { 5: 2 } },
            { id: 'stained_red', out: { id: 101, count: 2 }, requires: { 100: 1, 12: 1 } },
            { id: 'stained_blue', out: { id: 102, count: 2 }, requires: { 100: 1, 6: 1 } },
            { id: 'stained_green', out: { id: 103, count: 2 }, requires: { 100: 1, 8: 1 } },
            { id: 'stained_yellow', out: { id: 104, count: 2 }, requires: { 100: 1, 5: 1 } },
            { id: 'brick', out: { id: 105, count: 4 }, requires: { 13: 2, 4: 1 } },
            { id: 'smooth_stone', out: { id: 106, count: 4 }, requires: { 4: 4 } },
            { id: 'concrete', out: { id: 107, count: 4 }, requires: { 4: 2, 5: 2 } },
            { id: 'polished_wood', out: { id: 108, count: 2 }, requires: { 7: 2 } },
            { id: 'marble', out: { id: 109, count: 1 }, requires: { 4: 3, 10: 1 } },
            { id: 'obsidian', out: { id: 110, count: 1 }, requires: { 16: 1, 4: 1 } },
            { id: 'crystal_blue', out: { id: 111, count: 1 }, requires: { 100: 1, 6: 1 } },
            { id: 'crystal_purple', out: { id: 112, count: 1 }, requires: { 100: 1, 11: 1 } },
            { id: 'crystal_green', out: { id: 113, count: 1 }, requires: { 100: 1, 8: 1 } },
            { id: 'light_block', out: { id: 114, count: 1 }, requires: { 100: 1, 11: 1 } },
            { id: 'glow_brick', out: { id: 115, count: 1 }, requires: { 105: 1, 11: 1 } },
            { id: 'dark_glass', out: { id: 116, count: 1 }, requires: { 100: 1, 11: 1 } },
            { id: 'glass_tile', out: { id: 117, count: 2 }, requires: { 100: 2 } },
            { id: 'sandstone', out: { id: 118, count: 2 }, requires: { 5: 2 } },
            { id: 'cobblestone', out: { id: 119, count: 4 }, requires: { 4: 4 } },
        ];
        var scene, camera, renderer, controls;
        var meshGroup;
        var chunkManager;
        var raycaster = new THREE.Raycaster();
        var pointer = new THREE.Vector2(0, 0);
        var CHUNK_DELTAS = new Map();
        var worldSeed = 'KANYE';
        var worldName = 'KANYE';
        var userName = 'player';
        var userAddress = 'anonymous';
        var player = { x: 0, y: 24, z: 0, vx: 0, vy: 0, vz: 0, onGround: false, health: 20, score: 0, width: 0.6, height: 1.8, yaw: 0, pitch: 0 };
        var isAttacking = false;
        var attackStartTime = 0;
        var lastSentPosition = { x: 0, y: 0, z: 0, yaw: 0, pitch: 0 };
        var lastUpdateTime = 0;
        var lastStateUpdateTime = 0;
        var spawnPoint = { x: 0, y: 0, z: 0 };
        var lastSavedPosition = new THREE.Vector3(0, 24, 0);
        var selectedBlockId = null;
        var selectedHotIndex = 0;
        var hotbarOffset = 0;
        var cameraMode = 'third';
        var mobs = [];
        var lastDamageTime = 0;
        var lastRegenTime = 0;
        var joystick = { up: false, down: false, left: false, right: false };
        var lastFrame = performance.now();
        var mouseLocked = false;
        var deathScreenShown = false;
        var soundBreak = document.getElementById('soundBreak');
        var soundPlace = document.getElementById('soundPlace');
        var soundJump = document.getElementById('soundJump');
        var soundHit = document.getElementById('soundHit');
        var knownWorlds = new Map();
        var knownUsers = new Map();
        var keywordCache = new Map();
        var profileByURNCache = new Map();
        var profileByAddressCache = new Map();
        var keywordByAddressCache = new Map();
        var addressByKeywordCache = new Map();
        var pending = new Set();
        var spawnChunks = new Map();
        var chunkOwners = new Map();
        var apiCallTimestamps = [];
        var audioErrorLogged = false;
        var sun, moon, stars, clouds;
        var INVENTORY = new Array(32).fill(null);
        var isPromptOpen = false;
        var userPositions = {};
        var peers = new Map();
        var processedMessages = new Set();
        var initialPollDone = false;
        var isHost = false;
        var playerAvatars = new Map();
        var answerPollingIntervals = new Map();
        var offerPollingIntervals = new Map();

        const AVATAR_COLORS = [
            { body: 0x8338ec, leg: 0xff6b6b, head: 0xffd166 },
            { body: 0x3a86ff, leg: 0xffbe0b, head: 0xfb5607 },
            { body: 0x588157, leg: 0x3a5a40, head: 0xa3b18a },
            { body: 0xff006e, leg: 0x8338ec, head: 0xffbe0b },
            { body: 0x118ab2, leg: 0x073b4c, head: 0xef476f },
        ];

        function simpleHash(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = (hash << 5) - hash + char;
                hash |= 0; // Convert to 32bit integer
            }
            return Math.abs(hash);
        }

        async function getTurnCredentials() {
            // IMPORTANT: Replace with your own TURN server API key retrieval logic.
            // Do not hardcode API keys in client-side code for production environments.
            // This is a major security risk.
            // const apiKey = 'YOUR_API_KEY_HERE';
            // const response = await fetch(`https://your-turn-service.com/api/v1/turn?apiKey=${apiKey}`);
            // const credentials = await response.json();
            // return credentials;

            // Using a public STUN server as a fallback.
            // This will not work for all network configurations (symmetric NATs).
            console.warn("Using fallback STUN server. For production, a secure TURN server is recommended for robust connectivity.");
            return [{ urls: 'stun:stun.l.google.com:19302' }];
        }

        async function GetPublicAddressByKeyword(keyword) {
            try {
                if (addressByKeywordCache.has(keyword)) return addressByKeywordCache.get(keyword);
                await new Promise(function (r) { setTimeout(r, 1000 / API_CALLS_PER_SECOND); });
                var response = await fetch('https://p2fk.io/GetPublicAddressByKeyword/' + keyword + '?mainnet=false');
                if (!response.ok) {
                    addMessage('Failed to fetch address for keyword');
                    return null;
                }
                var address = await response.text();
                var cleanAddress = address ? address.trim() : null;
                if (cleanAddress) addressByKeywordCache.set(keyword, cleanAddress);
                return cleanAddress;
            } catch (e) {
                addMessage('Failed to fetch address for keyword');
                return null;
            }
        }
        async function GetPublicMessagesByAddress(address, skip, qty) {
            try {
                var cleanAddress = encodeURIComponent(address.trim().replace(/[^a-zA-Z0-9]/g, ''));
                await new Promise(function (r) { setTimeout(r, 1000 / API_CALLS_PER_SECOND); });
                var response = await fetch('https://p2fk.io/GetPublicMessagesByAddress/' + cleanAddress + '?skip=' + (skip || 0) + '&qty=' + (qty || 5000) + '&mainnet=false');
                if (!response.ok) {
                    addMessage('Failed to fetch messages: Invalid address');
                    return [];
                }
                var messages = await response.json();
                return messages;
            } catch (e) {
                addMessage('Failed to fetch messages');
                return [];
            }
        }
        async function GetProfileByURN(urn) {
            if (!urn || urn.trim() === '') return null;
            try {
                if (profileByURNCache.has(urn)) return profileByURNCache.get(urn);
                var cleanUrn = encodeURIComponent(urn.trim().replace(/[^a-zA-Z0-9]/g, ''));
                await new Promise(function (r) { setTimeout(r, 1000 / API_CALLS_PER_SECOND); });
                var response = await fetch('https://p2fk.io/GetProfileByURN/' + cleanUrn + '?mainnet=false');
                if (!response.ok) return null;
                var profile = await response.json();
                if (profile) profileByURNCache.set(urn, profile);
                return profile;
            } catch (e) {
                return null;
            }
        }
        async function GetProfileByAddress(address) {
            try {
                if (profileByAddressCache.has(address)) return profileByAddressCache.get(address);
                var cleanAddress = encodeURIComponent(address.trim().replace(/[^a-zA-Z0-9]/g, ''));
                await new Promise(function (r) { setTimeout(r, 1000 / API_CALLS_PER_SECOND); });
                var response = await fetch('https://p2fk.io/GetProfileByAddress/' + cleanAddress + '?mainnet=false');
                if (!response.ok) return null;
                var profile = await response.json();
                if (profile) profileByAddressCache.set(address, profile);
                return profile;
            } catch (e) {
                return null;
            }
        }
        async function GetKeywordByPublicAddress(address) {
            try {
                if (keywordByAddressCache.has(address)) return keywordByAddressCache.get(address);
                var cleanAddress = encodeURIComponent(address.trim().replace(/[^a-zA-Z0-9]/g, ''));
                await new Promise(function (r) { setTimeout(r, 1000 / API_CALLS_PER_SECOND); });
                var response = await fetch('https://p2fk.io/GetKeywordByPublicAddress/' + cleanAddress + '?mainnet=false');
                if (!response.ok) {
                    addMessage('Failed to fetch keyword for address');
                    return null;
                }
                var keyword = await response.text();
                var cleanKeyword = keyword ? keyword.trim() : null;
                if (cleanKeyword) keywordByAddressCache.set(address, cleanKeyword);
                return cleanKeyword;
            } catch (e) {
                addMessage('Failed to fetch keyword for address');
                return null;
            }
        }
        async function fetchIPFS(hash) {
            try {
                await new Promise(function (r) { setTimeout(r, 1000 / API_CALLS_PER_SECOND); });
                var response = await fetch('https://ipfs.io/ipfs/' + hash);
                if (!response.ok) {
                    addMessage('Failed to fetch IPFS data');
                    return null;
                }
                var data = await response.json();
                return data;
            } catch (e) {
                addMessage('Failed to fetch IPFS data');
                return null;
            }
        }
        async function applySaveFile(data, fromAddress, blockDate) {
            if (!data || !data.deltas) return;
            var fromProfile = await GetProfileByAddress(fromAddress);
            var username = fromProfile ? fromProfile.URN.replace(/[^a-zA-Z0-9]/g, '') : 'anonymous';
            var now = Date.now();
            for (var delta of data.deltas) {
                var chunkKey = delta.chunk.replace(/^#/, '');
                var changes = delta.changes;
                var ownership = chunkOwners.get(chunkKey) || { username: '', timestamp: 0, pending: true };
                if (!ownership.username || ownership.username === username || (now - ownership.timestamp >= OWNERSHIP_EXPIRY)) {
                    chunkManager.applyDeltasToChunk(chunkKey, changes);
                    chunkOwners.set(chunkKey, {
                        username: username,
                        timestamp: new Date(blockDate).getTime(),
                        pending: now - new Date(blockDate).getTime() < PENDING_PERIOD
                    });
                    addMessage('Updated chunk ' + chunkKey, 1000);
                } else {
                    addMessage('Cannot edit chunk ' + chunkKey + ': owned by another user', 3000);
                }
            }
            if (data.profile && fromAddress === userAddress) {
                lastSavedPosition = new THREE.Vector3(data.profile.x, data.profile.y, data.profile.z);
                INVENTORY = data.profile.inventory || new Array(32).fill(null);
                updateHotbarUI();
            }
        }
        var worker = new Worker(URL.createObjectURL(new Blob([`
const CHUNK_SIZE = 16;
const MAX_HEIGHT = 64;
const SEA_LEVEL = 16;
const MAP_SIZE = 16384;
const BLOCK_AIR = 0;

const BLOCKS = {
    1: { name: 'Bedrock', color: '#0b0b0b' }, 2: { name: 'Grass', color: '#3fb34f' },
    3: { name: 'Dirt', color: '#7a4f29' }, 4: { name: 'Stone', color: '#9aa0a6' },
    5: { name: 'Sand', color: '#e7d08d' }, 6: { name: 'Water', color: '#2b9cff', transparent: true },
    7: { name: 'Wood', color: '#8b5a33' }, 8: { name: 'Leaves', color: '#2f8f46' },
    9: { name: 'Cactus', color: '#4aa24a' }, 10: { name: 'Snow', color: '#ffffff' },
    11: { name: 'Coal', color: '#1f1f1f' }, 12: { name: 'Flower', color: '#ff6bcb' },
    13: { name: 'Clay', color: '#a9b6c0' }, 14: { name: 'Moss', color: '#507d43' },
    15: { name: 'Gravel', color: '#b2b2b2' }, 16: { name: 'Lava', color: '#ff6a00', transparent: true },
    17: { name: 'Ice', color: '#a8e6ff', transparent: true }, 100: { name: 'Glass', color: '#b3e6ff', transparent: true },
    101: { name: 'Stained Glass - Red', color: '#ff4b4b', transparent: true }, 102: { name: 'Stained Glass - Blue', color: '#4b6bff', transparent: true },
    103: { name: 'Stained Glass - Green', color: '#57c84d', transparent: true }, 104: { name: 'Stained Glass - Yellow', color: '#fff95b', transparent: true },
    105: { name: 'Brick', color: '#a84f3c' }, 106: { name: 'Smooth Stone', color: '#c1c1c1' },
    107: { name: 'Concrete', color: '#888888' }, 108: { name: 'Polished Wood', color: '#a87443' },
    109: { name: 'Marble', color: '#f0f0f0' }, 110: { name: 'Obsidian', color: '#2d004d' },
    111: { name: 'Crystal - Blue', color: '#6de0ff', transparent: true }, 112: { name: 'Crystal - Purple', color: '#b26eff', transparent: true },
    113: { name: 'Crystal - Green', color: '#6fff91', transparent: true }, 114: { name: 'Light Block', color: '#fffacd', transparent: true },
    115: { name: 'Glow Brick', color: '#f7cc5b' }, 116: { name: 'Dark Glass', color: '#3a3a3a', transparent: true },
    117: { name: 'Glass Tile', color: '#aeeaff', transparent: true }, 118: { name: 'Sandstone', color: '#e3c27d' },
    119: { name: 'Cobblestone', color: '#7d7d7d' },
};

const BIOMES = [
    { key: 'plains', palette: [2, 3, 4, 13, 15], heightScale: 0.8, roughness: 0.3, featureDensity: 0.05 },
    { key: 'desert', palette: [5, 118, 4], heightScale: 0.6, roughness: 0.4, featureDensity: 0.02 },
    { key: 'forest', palette: [2, 3, 14, 4], heightScale: 1.3, roughness: 0.4, featureDensity: 0.03 },
    { key: 'snow', palette: [10, 17, 4], heightScale: 1.2, roughness: 0.5, featureDensity: 0.02 },
    { key: 'mountain', palette: [4, 11, 3, 15, 1], heightScale: 10.5, roughness: 0.6, featureDensity: 0.01 },
    { key: 'swamp', palette: [2, 3, 6, 14, 13], heightScale: 0.5, roughness: 0.2, featureDensity: 0.04 },
];

function makeSeededRandom(seed) {
    var h = 2166136261 >>> 0;
    for (var i = 0; i < seed.length; i++) h = Math.imul(h ^ seed.charCodeAt(i), 16777619) >>> 0;
    return function () {
        h += 0x6D2B79F5;
        var t = Math.imul(h ^ (h >>> 15), 1 | h);
        t ^= t + Math.imul(t ^ (t >>> 7), 61 | t);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
}

function makeNoise(seed) {
    var rnd = makeSeededRandom(seed);
    var cache = {};
    function corner(ix, iy) {
        var k = ix + ',' + iy;
        if (cache[k] !== undefined) return cache[k];
        var s = seed + '|' + ix + ',' + iy;
        var r = makeSeededRandom(s)();
        return cache[k] = r;
    }
    function interp(a, b, t) { return a + (b - a) * (t * (t * (3 - 2 * t))); }
    return function (x, y) {
        var ix = Math.floor(x), iy = Math.floor(y);
        var fx = x - ix, fy = y - iy;
        var a = corner(ix, iy), b = corner(ix + 1, iy), c = corner(ix, iy + 1), d = corner(ix + 1, iy + 1);
        var ab = interp(a, b, fx), cd = interp(c, d, fx);
        return interp(ab, cd, fy);
    };
}

function fbm(noiseFn, x, y, oct, persistence) {
    var sum = 0, amp = 1, freq = 1, max = 0;
    for (var i = 0; i < oct; i++) {
        sum += amp * noiseFn(x * freq, y * freq);
        max += amp;
        amp *= persistence;
        freq *= 2;
    }
    return sum / max;
}

function placeTree(chunkData, lx, cy, lz, rnd) {
    var h = 5 + Math.floor(rnd() * 3);
    for (var i = 0; i < h; i++) if (cy + i < MAX_HEIGHT) chunkData[(cy + i) * CHUNK_SIZE * CHUNK_SIZE + lz * CHUNK_SIZE + lx] = 7;
    for (var dx = -2; dx <= 2; dx++) for (var dz = -2; dz <= 2; dz++) for (var dy = 0; dy <= 3; dy++) {
        var rx = lx + dx, ry = cy + h - 2 + dy, rz = lz + dz;
        if (ry < MAX_HEIGHT && rx >= 0 && rx < CHUNK_SIZE && rz >= 0 && rz < CHUNK_SIZE) {
            if (Math.abs(dx) + Math.abs(dz) + Math.abs(dy) <= 4 && chunkData[ry * CHUNK_SIZE * CHUNK_SIZE + rz * CHUNK_SIZE + rx] === BLOCK_AIR) chunkData[ry * CHUNK_SIZE * CHUNK_SIZE + rz * CHUNK_SIZE + rx] = 8;
        }
    }
}

function placeFlower(chunkData, lx, cy, lz) {
    if (cy < MAX_HEIGHT && chunkData[cy * CHUNK_SIZE * CHUNK_SIZE + lz * CHUNK_SIZE + lx] === BLOCK_AIR) chunkData[cy * CHUNK_SIZE * CHUNK_SIZE + lz * CHUNK_SIZE + lx] = 12;
}

function placeCactus(chunkData, lx, cy, lz, rnd) {
    var h = 1 + Math.floor(rnd() * 3);
    for (var i = 0; i < h; i++) if (cy + i < MAX_HEIGHT) chunkData[(cy + i) * CHUNK_SIZE * CHUNK_SIZE + lz * CHUNK_SIZE + lx] = 9;
}

function pickBiome(n) {
    if (n > 0.68) return BIOMES.find(b => b.key === 'snow') || BIOMES[0];
    if (n < 0.25) return BIOMES.find(b => b.key === 'desert') || BIOMES[1];
    if (n > 0.45) return BIOMES.find(b => b.key === 'forest') || BIOMES[2];
    if (n > 0.60) return BIOMES.find(b => b.key === 'mountain') || BIOMES[4];
    if (n < 0.35) return BIOMES.find(b => b.key === 'swamp') || BIOMES[5];
    return BIOMES.find(b => b.key === 'plains') || BIOMES[0];
}

function generateChunkData(chunkKey) {
    const noise = makeNoise(chunkKey.split(':')[0]);
    const blockNoise = makeNoise(chunkKey.split(':')[0] + '_block');
    const chunkRnd = makeSeededRandom(chunkKey);
    const cx = parseInt(chunkKey.split(':')[1]);
    const cz = parseInt(chunkKey.split(':')[2]);
    const chunkData = new Uint8Array(CHUNK_SIZE * MAX_HEIGHT * CHUNK_SIZE);

    var baseX = cx * CHUNK_SIZE;
    var baseZ = cz * CHUNK_SIZE;
    for (var lx = 0; lx < CHUNK_SIZE; lx++) {
        for (var lz = 0; lz < CHUNK_SIZE; lz++) {
            var wx = baseX + lx;
            var wz = baseZ + lz;
            var nx = (wx % MAP_SIZE) / MAP_SIZE * 10000;
            var nz = (wz % MAP_SIZE) / MAP_SIZE * 10000;
            var n = fbm(noise, nx * 0.005, nz * 0.005, 5, 0.6);
            var biome = pickBiome(n);
            var heightScale = biome.heightScale;
            var roughness = biome.roughness;
            var height = Math.floor(n * 40 * heightScale + 8);
            if (n > 0.7) height += Math.floor((n - 0.7) * 60 * heightScale);
            var localN = fbm(noise, nx * 0.05, nz * 0.05, 4, 0.5);
            height += Math.floor(localN * 15 * roughness);
            height = Math.max(1, Math.min(MAX_HEIGHT - 1, height));
            for (var y = 0; y <= height; y++) {
                var id = BLOCK_AIR;
                if (y === 0) id = 1;
                else if (y < height - 3) id = 4;
                else if (y < height) id = 3;
                else {
                    var blockN = fbm(blockNoise, nx * 0.1, nz * 0.1, 3, 0.6);
                    var paletteIndex = Math.floor(blockN * biome.palette.length);
                    id = biome.palette[paletteIndex % biome.palette.length];
                }
                chunkData[y * CHUNK_SIZE * CHUNK_SIZE + lz * CHUNK_SIZE + lx] = id;
            }
            for (var y = height + 1; y <= SEA_LEVEL; y++) chunkData[y * CHUNK_SIZE * CHUNK_SIZE + lz * CHUNK_SIZE + lx] = 6;
            if (biome.key === 'forest' && chunkRnd() < biome.featureDensity) placeTree(chunkData, lx, height + 1, lz, chunkRnd);
            else if (biome.key === 'plains' && chunkRnd() < biome.featureDensity) placeFlower(chunkData, lx, height + 1, lz);
            else if (biome.key === 'desert' && chunkRnd() < biome.featureDensity) placeCactus(chunkData, lx, height + 1, lz, chunkRnd);
        }
    }
    return chunkData;
}

var profileByURNCache = new Map();
var profileByAddressCache = new Map();
var keywordByAddressCache = new Map();
var addressByKeywordCache = new Map();
var processedMessages = new Set();
var API_CALLS_PER_SECOND = 8;
var apiDelay = 350;
async function fetchData(url) {
    try {
        await new Promise(resolve => setTimeout(resolve, apiDelay));
        var response = await fetch(url);
        return response.ok ? await response.json() : null;
    } catch (e) {
        console.error('[Worker] Fetch error:', url, e);
        return null;
    }
}
async function fetchText(url) {
    try {
        await new Promise(resolve => setTimeout(resolve, apiDelay));
        var response = await fetch(url);
        return response.ok ? await response.text() : null;
    } catch (e) {
        console.error('[Worker] Fetch text error:', url, e);
        return null;
    }
}
async function getPublicAddressByKeyword(keyword) {
    try {
        if (addressByKeywordCache.has(keyword)) return addressByKeywordCache.get(keyword);
        await new Promise(resolve => setTimeout(resolve, apiDelay));
        var response = await fetch("https://p2fk.io/GetPublicAddressByKeyword/" + keyword + "?mainnet=false");
        if (!response.ok) {
            console.error('[Worker] Failed to fetch address for keyword:', keyword, 'status:', response.status);
            return null;
        }
        var address = await response.text();
        var cleanAddress = address ? address.replace(/"|'/g, "").trim() : null;
        if (cleanAddress) addressByKeywordCache.set(keyword, cleanAddress);
        return cleanAddress;
    } catch (e) {
        console.error('[Worker] Error fetching address for keyword:', keyword, e);
        return null;
    }
}
async function getPublicMessagesByAddress(address, skip, qty) {
    try {
        var cleanAddress = encodeURIComponent(address.trim().replace(/[^a-zA-Z0-9]/g, ""));
        await new Promise(resolve => setTimeout(resolve, apiDelay));
        var response = await fetch("https://p2fk.io/GetPublicMessagesByAddress/" + cleanAddress + "?skip=" + skip + "&qty=" + qty + "&mainnet=false");
        if (!response.ok) {
            console.error('[Worker] Failed to fetch messages for address:', cleanAddress, 'status:', response.status);
            return [];
        }
        var messages = await response.json();
        return messages;
    } catch (e) {
        console.error('[Worker] Error fetching messages for address:', address, e);
        return [];
    }
}
async function getProfileByURN(urn) {
    if (!urn || urn.trim() === "") return null;
    try {
        if (profileByURNCache.has(urn)) return profileByURNCache.get(urn);
        var cleanUrn = encodeURIComponent(urn.trim().replace(/[^a-zA-Z0-9]/g, ""));
        await new Promise(resolve => setTimeout(resolve, apiDelay));
        var response = await fetch("https://p2fk.io/GetProfileByURN/" + cleanUrn + "?mainnet=false");
        if (!response.ok) {
            console.error('[Worker] Failed to fetch profile for URN:', cleanUrn, 'status:', response.status);
            return null;
        }
        var profile = await response.json();
        if (profile) profileByURNCache.set(urn, profile);
        return profile;
    } catch (e) {
        console.error('[Worker] Error fetching profile for URN:', urn, e);
        return null;
    }
}
async function getProfileByAddress(address) {
    try {
        if (profileByAddressCache.has(address)) return profileByAddressCache.get(address);
        var cleanAddress = encodeURIComponent(address.trim().replace(/[^a-zA-Z0-9]/g, ""));
        await new Promise(resolve => setTimeout(resolve, apiDelay));
        var response = await fetch("https://p2fk.io/GetProfileByAddress/" + cleanAddress + "?mainnet=false");
        if (!response.ok) {
            console.error('[Worker] Failed to fetch profile for address:', cleanAddress, 'status:', response.status);
            return null;
        }
        var profile = await response.json();
        if (profile) profileByAddressCache.set(address, profile);
        return profile;
    } catch (e) {
        console.error('[Worker] Error fetching profile for address:', address, e);
        return null;
    }
}
async function getKeywordByPublicAddress(address) {
    try {
        if (keywordByAddressCache.has(address)) return keywordByAddressCache.get(address);
        var cleanAddress = encodeURIComponent(address.trim().replace(/[^a-zA-Z0-9]/g, ""));
        await new Promise(resolve => setTimeout(resolve, apiDelay));
        var response = await fetch("https://p2fk.io/GetKeywordByPublicAddress/" + cleanAddress + "?mainnet=false");
        if (!response.ok) {
            console.error('[Worker] Failed to fetch keyword for address:', cleanAddress, 'status:', response.status);
            return null;
        }
        var keyword = await response.text();
        var cleanKeyword = keyword ? keyword.trim() : null;
        if (cleanKeyword) keywordByAddressCache.set(address, cleanKeyword);
        return cleanKeyword;
    } catch (e) {
        console.error('[Worker] Error fetching keyword for address:', address, e);
        return null;
    }
}
async function fetchIPFS(hash) {
    try {
        await new Promise(resolve => setTimeout(resolve, apiDelay));
        var response = await fetch("https://ipfs.io/ipfs/" + hash);
        if (!response.ok) {
            console.error('[Worker] Failed to fetch IPFS for hash:', hash, 'status:', response.status);
            return null;
        }
        var data = await response.json();
        return data;
    } catch (e) {
        console.error('[Worker] Error fetching IPFS for hash:', hash, e);
        return null;
    }
}
self.onmessage = async function(e) {
    var data = e.data;
    var type = data.type, chunkKeys = data.chunkKeys, masterKey = data.masterKey, userAddress = data.userAddress, worldName = data.worldName, serverKeyword = data.serverKeyword, offerKeyword = data.offerKeyword, answerKeywords = data.answerKeywords, userName = data.userName;

    if (type === 'generate_chunk') {
        const chunkData = generateChunkData(data.key);
        self.postMessage({ type: 'chunk_generated', key: data.key, data: chunkData }, [chunkData.buffer]);
        return;
    }

    console.log('[Worker] Received message type:', type, 'offerKeyword:', offerKeyword, 'worldName:', worldName);
    if (type === "sync_processed") {
        data.ids.forEach(id => processedMessages.add(id));
        console.log('[Worker] Synced processedMessages, size:', processedMessages.size);
        return;
    }
    if (type === "poll") {
        try {
            var masterAddr = await getPublicAddressByKeyword(masterKey);
            var worlds = new Map();
            var users = new Map();
            var joinData = [];
            var processedIds = [];
            if (masterAddr) {
                var messages = [];
                var skip = 0;
                var qty = 5000;
                while (true) {
                    var response = await getPublicMessagesByAddress(masterAddr, skip, qty);
                    if (!response || response.length === 0) break;
                    messages = messages.concat(response);
                    if (response.length < qty) break;
                    skip += qty;
                }
                for (var msg of messages || []) {
                    if (msg.TransactionId && processedMessages.has(msg.TransactionId)) {
                        console.log('[Worker] Stopping worlds_users processing at cached ID:', msg.TransactionId);
                        break; // Stop processing as all remaining messages are older
                    }
                    if (!msg.TransactionId) continue;
                    var fromProfile = await getProfileByAddress(msg.FromAddress);
                    if (!fromProfile || !fromProfile.URN) {
                        console.log('[Worker] Skipping worlds_users message, no URN for address:', msg.FromAddress, 'txId:', msg.TransactionId);
                        continue;
                    }
                    var user = fromProfile.URN.replace(/[^a-zA-Z0-9]/g, "");
                    var userProfile = await getProfileByURN(user);
                    if (!userProfile) {
                        console.log('[Worker] No profile for user:', user, 'txId:', msg.TransactionId);
                        users.set(user, msg.FromAddress); // Allow partial data
                        continue;
                    }
                    if (!userProfile.Creators || !userProfile.Creators.includes(msg.FromAddress)) {
                        console.log('[Worker] Skipping worlds_users message, invalid creators for user:', user, 'txId:', msg.TransactionId);
                        users.set(user, msg.FromAddress); // Allow partial data
                        continue;
                    }
                    var toKeywordRaw = await getKeywordByPublicAddress(msg.ToAddress);
                    if (!toKeywordRaw) {
                        console.log('[Worker] Skipping worlds_users message, no keyword for address:', msg.ToAddress, 'txId:', msg.TransactionId);
                        continue;
                    }
                    var toKeyword = toKeywordRaw.replace(/"|'/g, "");
                    if (!toKeyword.includes("MCUserJoin@")) {
                        console.log('[Worker] Skipping worlds_users message, invalid keyword:', toKeyword, 'txId:', msg.TransactionId);
                        continue;
                    }
                    var world = toKeyword.split("@")[1].replace(/[^a-zA-Z0-9]/g, "");
                    if (user && world) {
                        if (!worlds.has(world)) worlds.set(world, msg.ToAddress);
                        if (!users.has(user)) users.set(user, msg.FromAddress);
                        joinData.push({ user: user, world: world, username: user, transactionId: msg.TransactionId });
                        processedMessages.add(msg.TransactionId);
                        processedIds.push(msg.TransactionId);
                    }
                }
                self.postMessage({ type: "worlds_users", worlds: Object.fromEntries(worlds), users: Object.fromEntries(users), joinData: joinData, processedIds: processedIds });
            } else {
                console.error('[Worker] Failed to fetch master address for:', masterKey);
                self.postMessage({ type: "worlds_users", worlds: {}, users: {}, joinData: [], processedIds: [] });
            }
        } catch (e) {
            console.error('[Worker] Error in worlds_users poll:', e);
            self.postMessage({ type: "worlds_users", worlds: {}, users: {}, joinData: [], processedIds: [] });
        }
        var updatesByTransaction = new Map();
        var ownershipByChunk = new Map();
        for (var chunkKey of chunkKeys) {
            try {
                var normalizedChunkKey = chunkKey.replace(/^#/, "");
                var addr = await getPublicAddressByKeyword(normalizedChunkKey);
                if (!addr) {
                    console.log('[Worker] No address for chunk key:', normalizedChunkKey);
                    continue;
                }
                var messages = [];
                var skip = 0;
                var qty = 5000;
                while (true) {
                    var response = await getPublicMessagesByAddress(addr, skip, qty);
                    if (!response || response.length === 0) break;
                    messages = messages.concat(response);
                    if (response.length < qty) break;
                    skip += qty;
                }
                for (var msg of messages || []) {
                    if (msg.TransactionId && processedMessages.has(msg.TransactionId)) {
                        console.log('[Worker] Stopping chunk processing at cached ID:', msg.TransactionId);
                        break; // Stop processing as all remaining messages are older
                    }
                    if (!msg.TransactionId) continue;
                    var match = msg.Message.match(/IPFS:([a-zA-Z0-9]+)/);
                    if (match) {
                        var hash = match[1];
                        var cidRegex = /^[A-Za-z0-9]{46}$|^[A-Za-z0-9]{59}$|^[a-z0-9]+$/;
                        if (!cidRegex.test(hash)) {
                            console.log('[Worker] Invalid CID in chunk message:', hash, 'txId:', msg.TransactionId);
                            continue;
                        }
                        var data = await fetchIPFS(hash);
                        if (data && data.deltas) {
                            var normalizedDeltas = data.deltas.map(function(delta) {
                                return {
                                    chunk: delta.chunk.replace(/^#/, ""),
                                    changes: delta.changes
                                };
                            });
                            updatesByTransaction.set(msg.TransactionId, {
                                changes: normalizedDeltas,
                                address: msg.FromAddress,
                                timestamp: new Date(msg.BlockDate).getTime(),
                                transactionId: msg.TransactionId
                            });
                            for (var delta of normalizedDeltas) {
                                var chunk = delta.chunk;
                                if (!ownershipByChunk.has(chunk)) {
                                    var fromProfile = await getProfileByAddress(msg.FromAddress);
                                    if (fromProfile && fromProfile.URN) {
                                        var username = fromProfile.URN.replace(/[^a-zA-Z0-9]/g, "");
                                        ownershipByChunk.set(chunk, {
                                            chunkKey: chunk,
                                            username: username,
                                            timestamp: new Date(msg.BlockDate).getTime()
                                        });
                                    }
                                }
                            }
                        } else {
                            console.log('[Worker] No valid deltas in IPFS data for chunk message:', hash, 'txId:', msg.TransactionId);
                        }
                    }
                    processedMessages.add(msg.TransactionId);
                }
            } catch (e) {
                console.error('[Worker] Error in chunk poll:', e);
            }
        }
        if (updatesByTransaction.size > 0) {
            for (var entry of updatesByTransaction) {
                var transactionId = entry[0];
                var update = entry[1];
                self.postMessage({ type: "chunk_updates", updates: [{ changes: update.changes, address: update.address, timestamp: update.timestamp, transactionId: update.transactionId }] });
            }
        }
        if (ownershipByChunk.size > 0) {
            for (var ownership of ownershipByChunk.values()) {
                self.postMessage({ type: "chunk_ownership", chunkKey: ownership.chunkKey, username: ownership.username, timestamp: ownership.timestamp });
            }
        }
        try {
            var joinKeyword = userAddress === "anonymous" ? worldName : userAddress;
            var addressRes = await getPublicAddressByKeyword(joinKeyword);
            if (addressRes) {
                var messages = [];
                var skip = 0;
                var qty = 5000;
                while (true) {
                    var response = await getPublicMessagesByAddress(addressRes, skip, qty);
                    if (!response || response.length === 0) break;
                    messages = messages.concat(response);
                    if (response.length < qty) break;
                    skip += qty;
                }
                for (var msg of messages || []) {
                    if (msg.TransactionId && processedMessages.has(msg.TransactionId)) {
                        console.log('[Worker] Stopping user_update processing at cached ID:', msg.TransactionId);
                        break; // Stop processing as all remaining messages are older
                    }
                    if (msg.FromAddress === userAddress && !processedMessages.has(msg.TransactionId)) {
                        var match = msg.Message.match(/IPFS:([a-zA-Z0-9]+)/);
                        if (match) {
                            var hash = match[1];
                            var cidRegex = /^[A-Za-z0-9]{46}$|^[A-Za-z0-9]{59}$|^[a-z0-9]+$/;
                            if (!cidRegex.test(hash)) {
                                console.log('[Worker] Invalid CID in user_update message:', hash, 'txId:', msg.TransactionId);
                                continue;
                            }
                            var data = await fetchIPFS(hash);
                            if (data) {
                                self.postMessage({ type: "user_update", data: data, address: msg.FromAddress, timestamp: new Date(msg.BlockDate).getTime(), transactionId: msg.TransactionId });
                            } else {
                                console.log('[Worker] No valid data in IPFS for user_update:', hash, 'txId:', msg.TransactionId);
                            }
                        }
                        processedMessages.add(msg.TransactionId);
                    }
                }
            }
        } catch (e) {
            console.error('[Worker] Error in user_update poll:', e);
        }
        try {
            var serverAddr = await getPublicAddressByKeyword(serverKeyword);
            if (serverAddr) {
                var messages = [];
                var skip = 0;
                var qty = 5000;
                while (true) {
                    var response = await getPublicMessagesByAddress(serverAddr, skip, qty);
                    if (!response || response.length === 0) break;
                    messages = messages.concat(response);
                    if (response.length < qty) break;
                    skip += qty;
                }
                var servers = [];
                var processedIds = [];
                var messageMap = new Map();
                for (var msg of messages || []) {
                    if (msg.TransactionId && processedMessages.has(msg.TransactionId)) {
                        console.log('[Worker] Stopping server processing at cached ID:', msg.TransactionId);
                        break; // Stop processing as all remaining messages are older
                    }
                    if (!msg.TransactionId) continue;
                    var fromAddress = msg.FromAddress;
                    var timestamp = new Date(msg.BlockDate).getTime();
                    var existing = messageMap.get(fromAddress);
                    if (!existing || existing.timestamp < timestamp) {
                        messageMap.set(fromAddress, { msg: msg, timestamp: timestamp });
                    }
                }
                for (var entry of messageMap) {
                    var msg = entry[1].msg;
                    var timestamp = entry[1].timestamp;
                    var fromProfile = await getProfileByAddress(msg.FromAddress);
                    if (!fromProfile || !fromProfile.URN) {
                        console.log('[Worker] Skipping server message, no URN for address:', msg.FromAddress, 'txId:', msg.TransactionId);
                        continue;
                    }
                    var hostUser = fromProfile.URN.replace(/[^a-zA-Z0-9]/g, "");
                    var userProfile = await getProfileByURN(hostUser);
                    if (!userProfile) {
                        console.log('[Worker] Skipping server message, no profile for user:', hostUser, 'txId:', msg.TransactionId);
                        servers.push({ hostUser: hostUser, transactionId: msg.TransactionId, timestamp: timestamp }); // Still add server
                        continue;
                    }
                    if (!userProfile.Creators || !userProfile.Creators.includes(msg.FromAddress)) {
                        console.log('[Worker] Skipping server message, invalid creators for user:', hostUser, 'txId:', msg.TransactionId);
                        continue;
                    }
                    var match = msg.Message.match(/IPFS:([a-zA-Z0-9]+)/);
                    if (match) {
                        var hash = match[1];
                        var cidRegex = /^[A-Za-z0-9]{46}$|^[A-Za-z0-9]{59}$|^[a-z0-9]+$/;
                        if (!cidRegex.test(hash)) {
                            console.log('[Worker] Invalid CID in server message:', hash, 'txId:', msg.TransactionId);
                            continue;
                        }
                        var data = await fetchIPFS(hash);
                        if (data && data.world === worldName) {
                            servers.push({
                                hostUser: data.user || hostUser,
                                transactionId: msg.TransactionId,
                                timestamp: timestamp
                            });
                            processedMessages.add(msg.TransactionId);
                            processedIds.push(msg.TransactionId);
                        } else {
                            console.log('[Worker] Invalid IPFS data for server message:', hash, 'data:', JSON.stringify(data), 'txId:', msg.TransactionId);
                        }
                    }
                }
                if (servers.length > 0) {
                    self.postMessage({ type: "server_updates", servers: servers, processedIds: processedIds });
                }
            }
        } catch (e) {
            console.error('[Worker] Error in server_updates poll:', e);
        }
        try {
            if (offerKeyword) {
                var offerAddr = await getPublicAddressByKeyword(offerKeyword);
                if (offerAddr) {
                    var messages = [];
                    var skip = 0;
                    var qty = 5000;
                    while (true) {
                        var response = await getPublicMessagesByAddress(offerAddr, skip, qty);
                        if (!response || response.length === 0) break;
                        messages = messages.concat(response);
                        if (response.length < qty) break;
                        skip += qty;
                    }
                    var offers = [];
                    var processedIds = [];
                    var offerMap = new Map();
                    for (var msg of messages || []) {
                        if (msg.TransactionId && processedMessages.has(msg.TransactionId)) {
                            console.log('[Worker] Stopping offer processing at cached ID:', msg.TransactionId);
                            break; // Stop processing as all remaining messages are older
                        }
                        if (!msg.TransactionId) continue;
                        console.log('[Worker] Processing offer message:', msg.TransactionId, 'from:', msg.FromAddress);
                        processedMessages.add(msg.TransactionId);
                        processedIds.push(msg.TransactionId);
                        try {
                            var fromProfile = await getProfileByAddress(msg.FromAddress);
                            if (!fromProfile || !fromProfile.URN) {
                                console.log('[Worker] Skipping offer message, no URN for address:', msg.FromAddress, 'txId:', msg.TransactionId);
                                continue;
                            }
                            var clientUser = fromProfile.URN.replace(/[^a-zA-Z0-9]/g, "");
                            if (clientUser === userName) {
                                console.log('[Worker] Skipping offer from self:', clientUser, 'txId:', msg.TransactionId);
                                continue;
                            }
                            var userProfile = await getProfileByURN(clientUser);
                            if (!userProfile) {
                                console.log('[Worker] No profile for client user:', clientUser, 'txId:', msg.TransactionId);
                                offers.push({
                                    clientUser: clientUser,
                                    offer: null,
                                    iceCandidates: [],
                                    transactionId: msg.TransactionId,
                                    timestamp: new Date(msg.BlockDate).getTime(),
                                    profile: fromProfile
                                });
                                continue;
                            }
                            if (!userProfile.Creators || !userProfile.Creators.includes(msg.FromAddress)) {
                                console.log('[Worker] Skipping offer message, invalid creators for user:', clientUser, 'txId:', msg.TransactionId);
                                continue;
                            }
                            var match = msg.Message.match(/IPFS:([a-zA-Z0-9]+)/);
                            if (!match) {
                                console.log('[Worker] No IPFS hash in offer message:', msg.Message, 'txId:', msg.TransactionId);
                                offers.push({
                                    clientUser: clientUser,
                                    offer: null,
                                    iceCandidates: [],
                                    transactionId: msg.TransactionId,
                                    timestamp: new Date(msg.BlockDate).getTime(),
                                    profile: fromProfile
                                });
                                continue;
                            }
                            var hash = match[1];
                            var cidRegex = /^[A-Za-z0-9]{46}$|^[A-Za-z0-9]{59}$|^[a-z0-9]+$/;
                            if (!cidRegex.test(hash)) {
                                console.log('[Worker] Invalid CID in offer message:', hash, 'txId:', msg.TransactionId);
                                continue;
                            }
                            var data = await fetchIPFS(hash);
                            if (!data || !data.world || data.world !== worldName) {
                                console.log('[Worker] Invalid IPFS data for offer message:', hash, 'data:', JSON.stringify(data), 'txId:', msg.TransactionId);
                                continue;
                            }
                            if (data.offer || data.answer) {
                                if (!offerMap.has(clientUser)) {
                                    offerMap.set(clientUser, {
                                        clientUser: data.user || clientUser,
                                        offer: data.offer || data.answer,
                                        iceCandidates: data.iceCandidates || [],
                                        transactionId: msg.TransactionId,
                                        timestamp: new Date(msg.BlockDate).getTime(),
                                        profile: fromProfile
                                    });
                                }
                            } else {
                                console.log('[Worker] No offer or answer in IPFS data:', hash, 'data:', JSON.stringify(data), 'txId:', msg.TransactionId);
                                offers.push({
                                    clientUser: clientUser,
                                    offer: null,
                                    iceCandidates: [],
                                    transactionId: msg.TransactionId,
                                    timestamp: new Date(msg.BlockDate).getTime(),
                                    profile: fromProfile
                                });
                            }
                        } catch (e) {
                            console.error('[Worker] Error processing offer message:', msg.TransactionId, e);
                        }
                    }
                    offers = Array.from(offerMap.values());
                    if (offers.length > 0) {
                        console.log('[Worker] Sending offer_updates:', offers.map(o => o.clientUser));
                        self.postMessage({ type: "offer_updates", offers: offers, processedIds: processedIds });
                    } else {
                        console.log('[Worker] No new offers for:', offerKeyword);
                    }
                } else {
                    console.log('[Worker] No address for offer keyword:', offerKeyword);
                }
            } else {
                console.log('[Worker] No offerKeyword provided for offer polling');
            }
        } catch (e) {
            console.error('[Worker] Error in offer_updates poll:', e);
        }
        try {
            for (var answerKeyword of answerKeywords || []) {
                var answerAddr = await getPublicAddressByKeyword(answerKeyword);
                if (answerAddr) {
                    var messages = [];
                    var skip = 0;
                    var qty = 5000;
                    while (true) {
                        var response = await getPublicMessagesByAddress(answerAddr, skip, qty);
                        if (!response || response.length === 0) break;
                        messages = messages.concat(response);
                        if (response.length < qty) break;
                        skip += qty;
                    }
                    var answers = [];
                    var processedIds = [];
                    for (var msg of messages || []) {
                        if (msg.TransactionId && processedMessages.has(msg.TransactionId)) {
                            console.log('[Worker] Stopping answer processing at cached ID:', msg.TransactionId);
                            break; // Stop processing as all remaining messages are older
                        }
                        if (!msg.TransactionId) continue;
                        console.log('[Worker] Processing answer message:', msg.TransactionId, 'from:', msg.FromAddress);
                        processedMessages.add(msg.TransactionId);
                        processedIds.push(msg.TransactionId);
                        try {
                            var fromProfile = await getProfileByAddress(msg.FromAddress);
                            if (!fromProfile || !fromProfile.URN) {
                                console.log('[Worker] Skipping answer message, no URN for address:', msg.FromAddress, 'txId:', msg.TransactionId);
                                continue;
                            }
                            var hostUser = fromProfile.URN.replace(/[^a-zA-Z0-9]/g, "");
                            var userProfile = await getProfileByURN(hostUser);
                            if (!userProfile) {
                                console.log('[Worker] No profile for user:', hostUser, 'txId:', msg.TransactionId);
                                answers.push({
                                    hostUser: hostUser,
                                    answer: null,
                                    batch: null,
                                    iceCandidates: [],
                                    transactionId: msg.TransactionId,
                                    timestamp: new Date(msg.BlockDate).getTime()
                                });
                                continue;
                            }
                            if (!userProfile.Creators || !userProfile.Creators.includes(msg.FromAddress)) {
                                console.log('[Worker] Skipping answer message, invalid creators for user:', hostUser, 'txId:', msg.TransactionId);
                                continue;
                            }
                            var match = msg.Message.match(/IPFS:([a-zA-Z0-9]+)/);
                            if (!match) {
                                console.log('[Worker] No IPFS hash in answer message:', msg.Message, 'txId:', msg.TransactionId);
                                continue;
                            }
                            var hash = match[1];
                            var cidRegex = /^[A-Za-z0-9]{46}$|^[A-Za-z0-9]{59}$|^[a-z0-9]+$/;
                            if (!cidRegex.test(hash)) {
                                console.log('[Worker] Invalid CID in answer message:', hash, 'txId:', msg.TransactionId);
                                continue;
                            }
                            var data = await fetchIPFS(hash);
                            if (data && (data.answer || data.batch) && data.world === worldName) {
                                answers.push({
                                    hostUser: data.user || hostUser,
                                    answer: data.answer,
                                    batch: data.batch,
                                    iceCandidates: data.iceCandidates || [],
                                    transactionId: msg.TransactionId,
                                    timestamp: new Date(msg.BlockDate).getTime()
                                });
                            } else {
                                console.log('[Worker] Invalid IPFS data for answer message:', hash, 'data:', JSON.stringify(data), 'txId:', msg.TransactionId);
                            }
                        } catch (e) {
                            console.error('[Worker] Error in answer_updates poll:', e);
                        }
                    }
                    if (answers.length > 0) {
                        console.log('[Worker] Sending answer_updates:', answers);
                        self.postMessage({ type: "answer_updates", answers: answers, keyword: answerKeyword, processedIds: processedIds });
                    } else {
                        console.log('[Worker] No new answers for:', answerKeyword);
                    }
                } else {
                    console.log('[Worker] No address for answer keyword:', answerKeyword);
                }
            }
        } catch (e) {
            console.error('[Worker] Error in answer_updates poll:', e);
        }
    } else if (type === "update_processed") {
        data.transactionIds.forEach(function(id) { processedMessages.add(id); });
    } else if (type === "retry_chunk") {
        self.postMessage({ type: "poll", chunkKeys: [data.chunkKey], masterKey: masterKey, userAddress: userAddress, worldName: worldName });
    } else if (type === "cleanup_pending") {
        var pcx = data.pcx, pcz = data.pcz, pendingKeys = data.pendingKeys, chunksPerSide = data.chunksPerSide, pollRadius = data.pollRadius;
        var keysToDelete = [];
        for (var key of pendingKeys) {
            var match = key.match(/^([A-Z]{1,8}):(\d{1,5}):(\d{1,5})$/);
            if (match) {
                var cx = parseInt(match[2]);
                var cz = parseInt(match[3]);
                var dx = Math.min(Math.abs(cx - pcx), chunksPerSide - Math.abs(cx - pcx));
                var dz = Math.min(Math.abs(cz - pcz), chunksPerSide - Math.abs(cz - pcz));
                if (dx > pollRadius || dz > pollRadius) {
                    keysToDelete.push(key);
                }
            }
        }
        self.postMessage({ type: "cleanup_pending", keysToDelete: keysToDelete });
    }
};
    `], { type: 'application/javascript' })));
        worker.onmessage = function (e) {
            var data = e.data;
            if (data.type === "worlds_users") {
                console.log('[Users] Received worlds_users: worlds=', Object.keys(data.worlds || {}).length, 'users=', Object.keys(data.users || {}).length);
                if (data.worlds && typeof data.worlds === 'object' && Object.keys(data.worlds).length > 0) {
                    knownWorlds = new Map(Object.entries(data.worlds));
                } else {
                    console.log('[Users] Empty worlds_users data received, preserving existing knownWorlds');
                }
                if (data.users && typeof data.users === 'object' && Object.keys(data.users).length > 0) {
                    knownUsers = new Map(Object.entries(data.users));
                } else {
                    console.log('[Users] Empty users data received, preserving existing knownUsers');
                }
                if (data.processedIds) {
                    data.processedIds.forEach(id => processedMessages.add(id));
                }
                updateLoginUI();
            } else if (data.type === 'chunk_generated') {
                const chunk = chunkManager.chunks.get(data.key);
                if (chunk) {
                    chunk.data = data.data;
                    chunk.generated = true;
                    chunk.generating = false;
                    chunk.needsRebuild = true;
                }
            } else if (data.type === "server_updates") {
                console.log('[WebRTC] Received server_updates:', data.servers);
                var newServers = [];
                for (var server of data.servers || []) {
                    var existing = knownServers.find(s => s.hostUser === server.hostUser);
                    if (!existing || existing.timestamp < server.timestamp) {
                        var spawn = calculateSpawnPoint(server.hostUser + '@' + worldName);
                        newServers.push({
                            hostUser: server.hostUser,
                            spawn: spawn,
                            offer: null,
                            iceCandidates: [],
                            transactionId: server.transactionId,
                            timestamp: server.timestamp,
                            connectionRequestCount: existing ? existing.connectionRequestCount : 0,
                            latestRequestTime: existing ? existing.latestRequestTime : null
                        });
                    }
                    if (data.processedIds) {
                        data.processedIds.forEach(id => processedMessages.add(id));
                    }
                }
                if (newServers.length > 0) {
                    var serverMap = new Map();
                    for (var server of knownServers.concat(newServers)) {
                        if (!serverMap.has(server.hostUser) || serverMap.get(server.hostUser).timestamp < server.timestamp) {
                            serverMap.set(server.hostUser, server);
                        }
                    }
                    knownServers = Array.from(serverMap.values()).sort(function (a, b) { return b.timestamp - a.timestamp; }).slice(0, 10);
                    addMessage('New player(s) available to connect!', 3000);
                    updateHudButtons();
                }
            } else if (data.type === "offer_updates") {
                console.log('[WebRTC] Received offer_updates:', data.offers);
                if (data.offers && data.offers.length > 0) {
                    console.log('[WebRTC] Adding offers to pendingOffers:', data.offers.map(o => o.clientUser));
                    pendingOffers = pendingOffers.concat(data.offers);
                    addMessage('New connection request(s) received!', 5000);
                    updateHudButtons();
                    setupPendingModal();
                    if (isHost) {
                        document.getElementById('pendingModal').style.display = 'block';
                    }
                } else {
                    console.log('[WebRTC] No new offers received in offer_updates');
                }
                if (data.processedIds) {
                    data.processedIds.forEach(id => processedMessages.add(id));
                }
            } else if (data.type === "answer_updates") {
                console.log('[WebRTC] Received answer_updates for:', data.keyword, 'answers:', data.answers);
                for (var answer of data.answers || []) {
                    var peer = peers.get(answer.hostUser);
                    if (peer && peer.pc) {
                        try {
                            peer.pc.setRemoteDescription(new RTCSessionDescription(answer.answer));
                            for (var candidate of answer.iceCandidates || []) {
                                peer.pc.addIceCandidate(new RTCIceCandidate(candidate));
                            }
                            console.log('[WebRTC] Successfully processed answer for:', answer.hostUser);
                        } catch (e) {
                            console.error('[WebRTC] Failed to process answer for:', answer.hostUser, 'error:', e);
                        }
                    } else {
                        console.log('[WebRTC] No peer connection found for:', answer.hostUser);
                    }
                    if (data.processedIds) {
                        data.processedIds.forEach(id => processedMessages.add(id));
                    }
                }
            } else if (data.type === "chunk_updates") {
                console.log('[Worker] Received chunk_updates:', data.updates);
                for (var update of data.updates || []) {
                    applyChunkUpdates(update.changes, update.address, update.timestamp, update.transactionId);
                }
            } else if (data.type === "chunk_ownership") {
                console.log('[Worker] Received chunk_ownership:', data.chunkKey, data.username, data.timestamp);
                updateChunkOwnership(data.chunkKey, data.username, data.timestamp);
            } else if (data.type === "user_update") {
                console.log('[Worker] Received user_update:', data.transactionId);
                if (data.data.profile) {
                    var pos = data.data.profile;
                    if (pos.x !== undefined && pos.y !== undefined && pos.z !== undefined) {
                        userPositions[data.address] = pos;
                    }
                }
                if (data.transactionId) {
                    processedMessages.add(data.transactionId);
                    worker.postMessage({ type: 'update_processed', transactionIds: [data.transactionId] });
                }
            } else if (data.type === "cleanup_pending") {
                console.log('[Worker] Received cleanup_pending:', data.keysToDelete);
                for (var key of data.keysToDelete) {
                    pending.delete(key);
                }
            }
        };
        function startWorker() {
            console.log('[Worker] Initializing worker with isHost:', isHost, 'userName:', userName, 'worldName:', worldName);
            setInterval(function () {
                if (isPromptOpen) {
                    console.log('[Worker] Skipping poll, prompt open');
                    return;
                }
                var pcx = Math.floor(modWrap(player.x, MAP_SIZE) / CHUNK_SIZE);
                var pcz = Math.floor(modWrap(player.z, MAP_SIZE) / CHUNK_SIZE);

                var pendingKeys = Array.from(pending);
                if (pendingKeys.length > 0) {
                    worker.postMessage({
                        type: 'cleanup_pending',
                        pcx: pcx,
                        pcz: pcz,
                        pendingKeys: pendingKeys,
                        chunksPerSide: CHUNKS_PER_SIDE,
                        pollRadius: POLL_RADIUS
                    });
                }

                var chunkKeys = Array.from(chunkManager ? chunkManager.chunks.keys() : []);
                var filteredKeys = chunkKeys.filter(function (key) {
                    var parsed = parseChunkKey(key);
                    if (!parsed) return false;
                    var dx = Math.min(Math.abs(parsed.cx - pcx), CHUNKS_PER_SIDE - Math.abs(parsed.cx - pcx));
                    var dz = Math.min(Math.abs(parsed.cz - pcz), CHUNKS_PER_SIDE - Math.abs(parsed.cz - pcz));
                    return dx <= POLL_RADIUS && dz <= POLL_RADIUS;
                });
                var serverKeyword = 'MCServerJoin@' + worldName;
                var offerKeyword = isHost ? 'MCConn@' + userName + '@' + worldName : null;
                var answerKeywords = [];
                for (var peer of peers) {
                    var peerUser = peer[0];
                    if (peerUser !== userName) {
                        answerKeywords.push('MCAnswer@' + userName + '@' + worldName);
                    }
                }
                console.log('[Worker] Starting poll with offerKeyword:', offerKeyword, 'isHost:', isHost, 'answerKeywords:', answerKeywords);
                worker.postMessage({
                    type: 'poll',
                    chunkKeys: filteredKeys,
                    masterKey: MASTER_WORLD_KEY,
                    userAddress: userAddress,
                    worldName: worldName,
                    serverKeyword: serverKeyword,
                    offerKeyword: offerKeyword,
                    answerKeywords: answerKeywords,
                    userName: userName
                });
            }, POLL_INTERVAL);
        }
        function checkChunkOwnership(chunkKey, username) {
            const normalizedKey = chunkKey.replace(/^#/, '');
            if (spawnChunks.size > 0) {
                for (const [user, spawn] of spawnChunks) {
                    const parsed = parseChunkKey(normalizedKey);
                    if (!parsed) return false;
                    if (spawn.cx === parsed.cx && spawn.cz === parsed.cz && user !== username) {
                        return false;
                    }
                }
            }
            const ownership = chunkOwners.get(normalizedKey);
            if (!ownership) return true;
            const now = Date.now();
            if (now - ownership.timestamp > OWNERSHIP_EXPIRY) return true;
            if (ownership.pending && now - ownership.timestamp < PENDING_PERIOD) return true;
            return ownership.username === username;
        }
        var chunkOwnership = new Map();
        function updateChunkOwnership(chunkKey, username, timestamp) {
            console.log('[ChunkManager] Updating ownership for:', chunkKey, 'to:', username, 'at:', timestamp);
            try {
                chunkOwnership.set(chunkKey, { username, timestamp });
                console.log('[ChunkManager] Ownership updated:', chunkKey, chunkOwnership.get(chunkKey));
            } catch (e) {
                console.error('[ChunkManager] Failed to update chunk ownership:', e);
            }
        }
        function applyChunkUpdates(changes, address, timestamp, transactionId) {
            console.log('[ChunkManager] Applying chunk updates:', changes, 'from:', address, 'at:', timestamp, 'txId:', transactionId);
            try {
                for (var delta of changes) {
                    var chunkKey = delta.chunk;
                    var chunkChanges = delta.changes;
                    if (chunkManager) {
                        chunkManager.applyDeltasToChunk(chunkKey, chunkChanges);
                        chunkManager.markDirty(chunkKey);
                        console.log('[ChunkManager] Applied deltas to chunk:', chunkKey);
                    } else {
                        console.error('[ChunkManager] chunkManager not defined');
                    }
                }
                // Notify worker of processed transaction
                worker.postMessage({
                    type: 'update_processed',
                    transactionIds: [transactionId]
                });
            } catch (e) {
                console.error('[ChunkManager] Failed to apply chunk updates:', e);
            }
        }
        function makeSeededRandom(seed) {
            var h = 2166136261 >>> 0;
            for (var i = 0; i < seed.length; i++) h = Math.imul(h ^ seed.charCodeAt(i), 16777619) >>> 0;
            return function () {
                h += 0x6D2B79F5;
                var t = Math.imul(h ^ (h >>> 15), 1 | h);
                t ^= t + Math.imul(t ^ (t >>> 7), 61 | t);
                return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
            };
        }
        function makeNoise(seed) {
            var rnd = makeSeededRandom(seed);
            var cache = {};
            function corner(ix, iy) {
                var k = ix + ',' + iy;
                if (cache[k] !== undefined) return cache[k];
                var s = seed + '|' + ix + ',' + iy;
                var r = makeSeededRandom(s)();
                return cache[k] = r;
            }
            function interp(a, b, t) { return a + (b - a) * (t * (t * (3 - 2 * t))); }
            return function (x, y) {
                var ix = Math.floor(x), iy = Math.floor(y);
                var fx = x - ix, fy = y - iy;
                var a = corner(ix, iy), b = corner(ix + 1, iy), c = corner(ix, iy + 1), d = corner(ix + 1, iy + 1);
                var ab = interp(a, b, fx), cd = interp(c, d, fx);
                return interp(ab, cd, fy);
            };
        }
        function fbm(noiseFn, x, y, oct, persistence) {
            var sum = 0, amp = 1, freq = 1, max = 0;
            for (var i = 0; i < oct; i++) {
                sum += amp * noiseFn(x * freq, y * freq);
                max += amp;
                amp *= persistence;
                freq *= 2;
            }
            return sum / max;
        }
        function modWrap(n, m) {
            return ((n % m) + m) % m;
        }
        function makeChunkKey(world, cx, cz) {
            var clean = ('' + world).replace(/[^a-zA-Z0-9]/g, '').slice(0, 8);
            return clean + ':' + cx + ':' + cz;
        }
        function parseJsonChunkKey(key) {
            var match = key.match(/^#?([A-Z]{1,8}):(\d{1,5}):(\d{1,5})$/);
            if (match) {
                return {
                    world: match[1],
                    cx: parseInt(match[2]),
                    cz: parseInt(match[3])
                };
            }
            return null;
        }
        function parseChunkKey(key) {
            var match = key.match(/^([A-Z]{1,8}):(\d{1,5}):(\d{1,5})$/);
            if (match) {
                return {
                    world: match[1],
                    cx: parseInt(match[2]),
                    cz: parseInt(match[3])
                };
            }
            return null;
        }
        function hashSeed(seed) {
            var h = 2166136261 >>> 0;
            for (var i = 0; i < seed.length; i++) h = Math.imul(h ^ seed.charCodeAt(i), 16777619) >>> 0;
            return h % MAP_SIZE;
        }
        function calculateSpawnPoint(seed) {
            var rnd = makeSeededRandom(seed);
            var x = Math.floor(rnd() * MAP_SIZE);
            var z = Math.floor(rnd() * MAP_SIZE);
            var cx = Math.floor(x / CHUNK_SIZE);
            var cz = Math.floor(z / CHUNK_SIZE);
            var chunk = chunkManager.getChunk(cx, cz);
            if (!chunk.generated) chunkManager.generateChunk(chunk);
            var y = MAX_HEIGHT - 1;
            while (y > 0 && chunk.get(x % CHUNK_SIZE, y, z % CHUNK_SIZE) === BLOCK_AIR) y--;
            y += 2;
            return { x: x, y: y, z: z };
        }
        function initSky() {
            sun = new THREE.Mesh(
                new THREE.SphereGeometry(10, 32, 32),
                new THREE.MeshBasicMaterial({ color: 0xffff00 })
            );
            moon = new THREE.Mesh(
                new THREE.SphereGeometry(8, 32, 32),
                new THREE.MeshBasicMaterial({ color: 0xcccccc })
            );
            stars = new THREE.Group();
            var starGeometry = new THREE.BufferGeometry();
            var starVertices = [];
            var starNoise = makeNoise(worldSeed + '_stars');
            for (var i = 0; i < 1000; i++) {
                var theta = Math.random() * Math.PI * 2;
                var phi = Math.acos(2 * Math.random() - 1);
                var x = 1000 * Math.sin(phi) * Math.cos(theta);
                var y = 1000 * Math.sin(phi) * Math.sin(theta);
                var z = 1000 * Math.cos(phi);
                if (starNoise(x * 0.01, z * 0.01) > 0.7) {
                    starVertices.push(x, y, z);
                }
            }
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            var starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 2 });
            var starPoints = new THREE.Points(starGeometry, starMaterial);
            stars.add(starPoints);
            clouds = new THREE.Group();
            for (var i = 0; i < 20; i++) {
                var cloud = new THREE.Mesh(
                    new THREE.PlaneGeometry(50, 50),
                    new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.4, side: THREE.DoubleSide })
                );
                cloud.position.set(
                    (Math.random() - 0.5) * 2000,
                    100 + Math.random() * 50,
                    (Math.random() - 0.5) * 2000
                );
                clouds.add(cloud);
            }
            scene.add(sun, moon, stars, clouds);
        }
        function updateSky(dt) {
            var now = new Date();
            var hours = now.getHours() + now.getMinutes() / 60;
            var t = (hours / 24) * Math.PI * 2;
            var isNight = hours >= 18 || hours < 6;
            var sunAngle = t;
            var moonAngle = t + Math.PI;
            sun.position.set(1000 * Math.cos(sunAngle), 1000 * Math.sin(sunAngle), 0);
            moon.position.set(1000 * Math.cos(moonAngle), 1000 * Math.sin(moonAngle), 0);
            stars.visible = isNight;
            clouds.children.forEach(function (cloud) {
                cloud.position.x = modWrap(cloud.position.x + dt * 10, 2000);
                cloud.lookAt(camera.position);
            });
            var dayColor = new THREE.Color(0x87ceeb);
            var nightColor = new THREE.Color(0x1c2526);
            var tNorm = Math.sin(t) * 0.5 + 0.5;
            scene.background = dayColor.lerp(nightColor, tNorm);
            var ambientLight = scene.getObjectByProperty('type', 'AmbientLight');
            ambientLight.intensity = isNight ? 0.2 : 0.45;
            sun.visible = !isNight;
            moon.visible = isNight;
        }
        function Chunk(cx, cz) {
            this.cx = cx;
            this.cz = cz;
            this.key = makeChunkKey(worldName, cx, cz);
            this.data = new Uint8Array(CHUNK_SIZE * MAX_HEIGHT * CHUNK_SIZE);
            this.mesh = null;
            this.generated = false;
            this.needsRebuild = true;
        }
        Chunk.prototype.idx = function (x, y, z) { return (y * CHUNK_SIZE + z) * CHUNK_SIZE + x; };
        Chunk.prototype.get = function (x, y, z) {
            if (x < 0 || x >= CHUNK_SIZE || z < 0 || z >= CHUNK_SIZE || y < 0 || y >= MAX_HEIGHT) return BLOCK_AIR;
            return this.data[this.idx(x, y, z)];
        };
        Chunk.prototype.set = function (x, y, z, v) {
            if (x < 0 || x >= CHUNK_SIZE || z < 0 || z >= CHUNK_SIZE || y < 0 || y >= MAX_HEIGHT) return;
            this.data[this.idx(x, y, z)] = v;
            this.needsRebuild = true;
        };
        function ChunkManager(seed) {
            console.log('[WorldGen] Initializing ChunkManager with seed:', seed);
            this.seed = seed;
            this.noise = makeNoise(seed);
            this.blockNoise = makeNoise(seed + '_block');
            this.chunks = new Map();
            this.lastPcx = null;
            this.lastPcz = null;
            this.currentLoadRadius = 2; // Initial small radius
            // meshGroup is already defined and added to scene in initThree(); do not redefine here
            console.log('[ChunkManager] Using existing meshGroup for chunk rendering');
        }
        ChunkManager.prototype.getChunk = function (cx, cz) {
            var chunksPerSide = Math.floor(MAP_SIZE / CHUNK_SIZE);
            var wrappedCx = modWrap(cx, chunksPerSide);
            var wrappedCz = modWrap(cz, chunksPerSide);
            var key = makeChunkKey(worldName, wrappedCx, wrappedCz);
            if (this.chunks.has(key)) return this.chunks.get(key);
            var c = new Chunk(wrappedCx, wrappedCz);
            this.chunks.set(c.key, c);
            pending.add(c.key);
            return c;
        };
        ChunkManager.prototype.generateChunk = function (chunk) {
            if (chunk.generating || chunk.generated) return;
            chunk.generating = true;
            worker.postMessage({ type: 'generate_chunk', key: chunk.key });
        };
        ChunkManager.prototype.pickBiome = function (n) {
            if (n > 0.68) return BIOMES.find(function (b) { return b.key === 'snow'; }) || BIOMES[0];
            if (n < 0.25) return BIOMES.find(function (b) { return b.key === 'desert'; }) || BIOMES[1];
            if (n > 0.45) return BIOMES.find(function (b) { return b.key === 'forest'; }) || BIOMES[2];
            if (n > 0.60) return BIOMES.find(function (b) { return b.key === 'mountain'; }) || BIOMES[4];
            if (n < 0.35) return BIOMES.find(function (b) { return b.key === 'swamp'; }) || BIOMES[5];
            return BIOMES.find(function (b) { return b.key === 'plains'; }) || BIOMES[0];
        };
        ChunkManager.prototype.placeTree = function (chunk, lx, cy, lz, rnd) {
            var h = 5 + Math.floor(rnd() * 3);
            for (var i = 0; i < h; i++) if (cy + i < MAX_HEIGHT) chunk.set(lx, cy + i, lz, 7);
            for (var dx = -2; dx <= 2; dx++) for (var dz = -2; dz <= 2; dz++) for (var dy = 0; dy <= 3; dy++) {
                var rx = lx + dx, ry = cy + h - 2 + dy, rz = lz + dz;
                if (ry < MAX_HEIGHT && rx >= 0 && rx < CHUNK_SIZE && rz >= 0 && rz < CHUNK_SIZE) {
                    if (Math.abs(dx) + Math.abs(dz) + Math.abs(dy) <= 4 && chunk.get(rx, ry, rz) === BLOCK_AIR) chunk.set(rx, ry, rz, 8);
                }
            }
        };
        ChunkManager.prototype.placeFlower = function (chunk, lx, cy, lz) {
            if (cy < MAX_HEIGHT && chunk.get(lx, cy, lz) === BLOCK_AIR) chunk.set(lx, cy, lz, 12);
        };
        ChunkManager.prototype.placeCactus = function (chunk, lx, cy, lz, rnd) {
            var h = 1 + Math.floor(rnd() * 3);
            for (var i = 0; i < h; i++) if (cy + i < MAX_HEIGHT) chunk.set(lx, cy + i, lz, 9);
        };
        ChunkManager.prototype.buildChunkMesh = function (chunk) {
            if (chunk.mesh) { meshGroup.remove(chunk.mesh); disposeObject(chunk.mesh); chunk.mesh = null; }
            var lists = {};
            var baseX = chunk.cx * CHUNK_SIZE;
            var baseZ = chunk.cz * CHUNK_SIZE;
            for (var x = 0; x < CHUNK_SIZE; x++) {
                for (var z = 0; z < CHUNK_SIZE; z++) {
                    for (var y = 0; y < MAX_HEIGHT; y++) {
                        var id = chunk.get(x, y, z);
                        if (!id || id === BLOCK_AIR) continue;
                        var wx = modWrap(baseX + x, MAP_SIZE);
                        var wz = modWrap(baseZ + z, MAP_SIZE);
                        var exposed = (
                            this.getBlockGlobal(chunk.cx, chunk.cz, x + 1, y, z) === BLOCK_AIR ||
                            this.getBlockGlobal(chunk.cx, chunk.cz, x - 1, y, z) === BLOCK_AIR ||
                            this.getBlockGlobal(chunk.cx, chunk.cz, x, y + 1, z) === BLOCK_AIR ||
                            this.getBlockGlobal(chunk.cx, chunk.cz, x, y - 1, z) === BLOCK_AIR ||
                            this.getBlockGlobal(chunk.cx, chunk.cz, x, y, z + 1) === BLOCK_AIR ||
                            this.getBlockGlobal(chunk.cx, chunk.cz, x, y, z - 1) === BLOCK_AIR
                        );
                        if (!exposed) continue;
                        if (!lists[id]) lists[id] = [];
                        lists[id].push({ x: wx, y: y, z: wz });
                    }
                }
            }
            var group = new THREE.Group();
            for (var idStr in lists) {
                var arr = lists[idStr];
                if (!arr || arr.length === 0) continue;
                var id = parseInt(idStr);
                var box = new THREE.BoxGeometry(1, 1, 1);
                var positions = []; var normals = []; var uvs = []; var indices = []; var vertOffset = 0;
                for (var p of arr) {
                    var posAttr = box.attributes.position.array;
                    var normAttr = box.attributes.normal.array;
                    var uvAttr = box.attributes.uv.array;
                    var idxAttr = box.index.array;
                    for (var vi = 0; vi < box.attributes.position.count; vi++) {
                        positions.push(posAttr[vi * 3 + 0] + p.x, posAttr[vi * 3 + 1] + p.y, posAttr[vi * 3 + 2] + p.z);
                        normals.push(normAttr[vi * 3 + 0], normAttr[vi * 3 + 1], normAttr[vi * 3 + 2]);
                        uvs.push(uvAttr[vi * 2 + 0], uvAttr[vi * 2 + 1]);
                    }
                    for (var ii = 0; ii < idxAttr.length; ii++) indices.push(idxAttr[ii] + vertOffset);
                    vertOffset += box.attributes.position.count;
                }
                var geom = new THREE.BufferGeometry();
                geom.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                geom.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
                geom.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
                geom.setIndex(indices);
                geom.computeBoundingSphere();
                var info = BLOCKS[id] || { color: '#ff00ff' };
                var mat = info.transparent ?
                    new THREE.MeshBasicMaterial({ color: new THREE.Color(info.color), transparent: true, opacity: 0.6, side: THREE.DoubleSide }) :
                    new THREE.MeshLambertMaterial({ color: new THREE.Color(info.color) });
                var mesh = new THREE.Mesh(geom, mat);
                group.add(mesh);
            }
            chunk.mesh = group;
            meshGroup.add(chunk.mesh);
            chunk.needsRebuild = false;
        };
        ChunkManager.prototype.getBlockGlobal = function (cx, cz, lx, y, lz) {
            var chunksPerSide = Math.floor(MAP_SIZE / CHUNK_SIZE);
            var wrappedWx = modWrap(cx * CHUNK_SIZE + lx, MAP_SIZE);
            var wrappedWz = modWrap(cz * CHUNK_SIZE + lz, MAP_SIZE);
            var newCx = Math.floor(wrappedWx / CHUNK_SIZE);
            var newCz = Math.floor(wrappedWz / CHUNK_SIZE);
            var newLx = modWrap(wrappedWx, CHUNK_SIZE);
            var newLz = modWrap(wrappedWz, CHUNK_SIZE);
            var chunk = this.getChunk(newCx, newCz);
            if (!chunk.generated) this.generateChunk(chunk);
            return chunk.get(newLx, y, newLz);
        };
        ChunkManager.prototype.setBlockGlobal = function (wx, wy, wz, bid, doBroadcast = true) {
            if (wy < 0 || wy >= MAX_HEIGHT) return;
            var wrappedWx = modWrap(wx, MAP_SIZE);
            var wrappedWz = modWrap(wz, MAP_SIZE);
            var cx = Math.floor(wrappedWx / CHUNK_SIZE);
            var cz = Math.floor(wrappedWz / CHUNK_SIZE);
            var lx = Math.floor(wrappedWx % CHUNK_SIZE);
            var lz = Math.floor(wrappedWz % CHUNK_SIZE);
            var chunk = this.getChunk(cx, cz);
            if (!chunk.generated) this.generateChunk(chunk);
            var prev = chunk.get(lx, wy, lz);
            if (prev === bid) return;
            chunk.set(lx, wy, lz, bid);
            var key = chunk.key;
            if (!CHUNK_DELTAS.has(key)) CHUNK_DELTAS.set(key, []);
            CHUNK_DELTAS.get(key).push({ x: lx, y: wy, z: lz, b: bid });
            chunk.needsRebuild = true;
            safePlayAudio(soundPlace);
            updateSaveChangesButton();

            if (doBroadcast) {
                const message = JSON.stringify({
                    type: 'block_change',
                    wx: wx, wy: wy, wz: wz, bid: bid,
                    username: userName // Let the server know who made the change
                });

                // Both host and client send the change to their peer(s).
                // The host will then relay this to other clients.
                for (const [peerUser, peerData] of peers.entries()) {
                    if (peerUser !== userName && peerData.dc && peerData.dc.readyState === 'open') {
                         console.log(`[WebRTC] Sending block change to ${peerUser}`);
                         peerData.dc.send(message);
                    }
                }
            }
        };
        ChunkManager.prototype.applyDeltasToChunk = function (chunkKey, changes) {
            var normalizedKey = chunkKey.replace(/^#/, '');
            var parsed = parseChunkKey(normalizedKey);
            if (!parsed) return;
            var chunk = this.chunks.get(normalizedKey);
            if (!chunk) return;
            for (var d of changes) {
                if (d.x < 0 || d.x >= CHUNK_SIZE || d.y < 0 || d.y >= MAX_HEIGHT || d.z < 0 || d.z >= CHUNK_SIZE) continue;
                chunk.set(d.x, d.y, d.z, d.b);
            }
            chunk.needsRebuild = true;
            this.buildChunkMesh(chunk);
        };
        ChunkManager.prototype.markDirty = function (chunkKey) {
            var chunk = this.chunks.get(chunkKey);
            if (chunk) {
                chunk.needsRebuild = true;
                this.buildChunkMesh(chunk);
            }
        };
        ChunkManager.prototype.getSurfaceY = function (wx, wz) {
            var wrappedWx = modWrap(Math.floor(wx), MAP_SIZE);
            var wrappedWz = modWrap(Math.floor(wz), MAP_SIZE);
            var cx = Math.floor(wrappedWx / CHUNK_SIZE);
            var cz = Math.floor(wrappedWz / CHUNK_SIZE);
            var chunk = this.getChunk(cx, cz);
            if (!chunk.generated) this.generateChunk(chunk);
            var lx = Math.floor(wrappedWx % CHUNK_SIZE);
            var lz = Math.floor(wrappedWz % CHUNK_SIZE);
            for (var y = MAX_HEIGHT - 1; y >= 0; y--) {
                if (chunk.get(lx, y, lz) !== BLOCK_AIR && chunk.get(lx, y, lz) !== 6) return y + 1;
            }
            return SEA_LEVEL;
        };
        ChunkManager.prototype.preloadChunks = function (cx, cz, radius) {
            var chunksPerSide = Math.floor(MAP_SIZE / CHUNK_SIZE);
            var queue = [];
            for (var r = 0; r <= radius; r++) {
                for (var dx = -r; dx <= r; dx++) {
                    for (var dz = -r; dz <= r; dz++) {
                        if (Math.abs(dx) === r || Math.abs(dz) === r) {
                            queue.push({ cx: cx + dx, cz: cz + dz, dist: Math.abs(dx) + Math.abs(dz) });
                        }
                    }
                }
            }
            queue.sort(function (a, b) { return a.dist - b.dist; });
            var index = 0;
            function processNext() {
                if (index >= queue.length) return;
                var dcx = queue[index].cx, dcz = queue[index].cz;
                var wrappedCx = modWrap(dcx, chunksPerSide);
                var wrappedCz = modWrap(dcz, chunksPerSide);
                var chunk = this.getChunk(wrappedCx, wrappedCz);
                if (!chunk.generated) this.generateChunk(chunk);
                if (chunk.needsRebuild || !chunk.mesh) this.buildChunkMesh(chunk);
                index++;
                setTimeout(processNext.bind(this), 333);
            }
            processNext.call(this);
        };
        ChunkManager.prototype.update = function (playerX, playerZ) {
            var pcx = Math.floor(modWrap(playerX, MAP_SIZE) / CHUNK_SIZE);
            var pcz = Math.floor(modWrap(playerZ, MAP_SIZE) / CHUNK_SIZE);
            if (pcx !== this.lastPcx || pcz !== this.lastPcz) {
                this.lastPcx = pcx;
                this.lastPcz = pcz;
            }
            const distanceToEdge = Math.max(Math.abs(pcx - this.lastPcx), Math.abs(pcz - this.lastPcz));
            if (distanceToEdge > this.currentLoadRadius - 2 && this.currentLoadRadius < LOAD_RADIUS) {
                this.currentLoadRadius++;
                console.log("Expanding load radius to:", this.currentLoadRadius);
            }

            var needed = new Set();
            for (var dx = -this.currentLoadRadius; dx <= this.currentLoadRadius; dx++) {
                for (var dz = -this.currentLoadRadius; dz <= this.currentLoadRadius; dz++) {
                    var cx = modWrap(pcx + dx, CHUNKS_PER_SIDE);
                    var cz = modWrap(pcz + dz, CHUNKS_PER_SIDE);
                    var ch = this.getChunk(cx, cz);
                    needed.add(ch.key);
                    if (!ch.generating && !ch.generated) this.generateChunk(ch);
                    if (ch.generated && (ch.needsRebuild || !ch.mesh)) this.buildChunkMesh(ch);
                }
            }
            for (var peerUser in userPositions) {
                if (peerUser !== userName) {
                    var pos = userPositions[peerUser];
                    var peerCx = Math.floor(modWrap(pos.x, MAP_SIZE) / CHUNK_SIZE);
                    var peerCz = Math.floor(modWrap(pos.z, MAP_SIZE) / CHUNK_SIZE);
                    this.preloadChunks(peerCx, peerCz, 2);
                }
            }
            for (var entry of this.chunks) {
                var k = entry[0];
                var ch = entry[1];
                if (!needed.has(k)) {
                    if (ch.mesh) {
                        meshGroup.remove(ch.mesh);
                        disposeObject(ch.mesh);
                        ch.mesh = null;
                    }
                }
            }
        };
        function initThree() {
            console.log('[initThree] Starting');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            console.log('[initThree] Scene created');
            camera = new THREE.PerspectiveCamera(70, innerWidth / innerHeight, 0.1, 2000);
            camera.position.set(0, 34, 0);
            console.log('[initThree] Camera created');
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(innerWidth, innerHeight);
            renderer.setPixelRatio(Math.min(2, window.devicePixelRatio));
            document.body.appendChild(renderer.domElement);
            console.log('[initThree] Renderer created and appended');
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.maxPolarAngle = Math.PI / 2;
            controls.minDistance = 2;
            controls.maxDistance = 100;
            controls.enabled = false;
            console.log('[initThree] Controls created');
            var dir = new THREE.DirectionalLight(0xffffff, 0.95);
            dir.position.set(100, 200, 100);
            scene.add(dir);
            scene.add(new THREE.AmbientLight(0xffffff, 0.45));
            console.log('[initThree] Lights added');
            meshGroup = new THREE.Group();
            scene.add(meshGroup);
            console.log('[initThree] Mesh group created');
            initSky();
            console.log('[initThree] Sky initialized');
            renderer.domElement.addEventListener('pointerdown', function (e) { onPointerDown(e); });
            renderer.domElement.addEventListener('wheel', function (e) {
                e.preventDefault();
                if (cameraMode === 'first') {
                    var delta = e.deltaY > 0 ? 1 : -1;
                    selectedHotIndex = (selectedHotIndex + delta + INVENTORY.length) % INVENTORY.length;
                    updateHotbarUI();
                }
            });
            renderer.domElement.addEventListener('click', function () {
                if (cameraMode === 'first' && !mouseLocked && !isMobile()) {
                    try {
                        renderer.domElement.requestPointerLock();
                        mouseLocked = true;
                        document.getElementById('crosshair').style.display = 'block';
                    } catch (e) {
                        addMessage('Pointer lock failed. Serve over HTTPS or check iframe permissions.');
                    }
                }
            });

    let touchStartX = 0;
    let touchStartY = 0;
    renderer.domElement.addEventListener('touchstart', e => {
        let target = e.target;
        let isButton = false;
        while(target && target !== document.body) {
            if (target.classList.contains('m-btn') || target.classList.contains('m-action')) {
                isButton = true;
                break;
            }
            target = target.parentElement;
        }

        if (isButton) return;

        if (cameraMode === 'first' && e.touches.length > 0) {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
            e.preventDefault(); // Prevent scrolling/zooming
        }
    }, { passive: false });

    renderer.domElement.addEventListener('touchmove', e => {
        if (cameraMode === 'first' && e.touches.length > 0) {
            const touchX = e.touches[0].clientX;
            const touchY = e.touches[0].clientY;

            const deltaX = touchX - touchStartX;
            const deltaY = touchY - touchStartY;

            const sensitivity = 0.005; // Mobile sensitivity
            player.yaw -= deltaX * sensitivity;
            player.pitch -= deltaY * sensitivity;
            player.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, player.pitch));
            camera.rotation.set(player.pitch, player.yaw, 0, 'YXZ');

            if (avatarGroup && avatarGroup.children[3]) {
                avatarGroup.children[3].rotation.set(player.pitch, 0, 0);
            }

            touchStartX = touchX;
            touchStartY = touchY;
            e.preventDefault(); // Prevent scrolling/zooming
        }
    }, { passive: false });
            document.addEventListener('pointerlockchange', function () {
                mouseLocked = document.pointerLockElement === renderer.domElement;
                document.getElementById('crosshair').style.display = mouseLocked && cameraMode === 'first' ? 'block' : 'none';
            });
            renderer.domElement.addEventListener('mousemove', function (e) {
                if (cameraMode === 'first' && mouseLocked) {
                    var sensitivity = 0.002;
                    player.yaw -= e.movementX * sensitivity;
                    player.pitch -= e.movementY * sensitivity;
                    player.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, player.pitch));
                    camera.rotation.set(player.pitch, player.yaw, 0, 'YXZ');

                    if (avatarGroup) {
                        avatarGroup.children[3].rotation.set(player.pitch, 0, 0);
                    }
                }
            });
            window.addEventListener('resize', function () {
                camera.aspect = innerWidth / innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(innerWidth, innerHeight);
                updateMinimap();
            });
            createPlayerAvatar();
        }
        var avatarGroup;
        function createPlayerAvatar() {
            avatarGroup = new THREE.Group();
            var legMat = new THREE.MeshStandardMaterial({ color: 0x6b8cff });
            var bodyMat = new THREE.MeshStandardMaterial({ color: 0x2b8f87 });
            var headMat = new THREE.MeshStandardMaterial({ color: 0xf2c57c });
            var armMat = new THREE.MeshStandardMaterial({ color: 0xf2c57c });

            var legGeo = new THREE.BoxGeometry(0.4, 0.8, 0.4); // Shorter legs
            var bodyGeo = new THREE.BoxGeometry(0.8, 1.2, 0.4);
            var headGeo = new THREE.BoxGeometry(0.6, 0.6, 0.6);
            var armGeo = new THREE.BoxGeometry(0.3, 1.2, 0.3);

            var leftLeg = new THREE.Mesh(legGeo, legMat);
            leftLeg.position.set(-0.25, 0.4, 0); // Adjusted Y position
            var rightLeg = new THREE.Mesh(legGeo, legMat);
            rightLeg.position.set(0.25, 0.4, 0); // Adjusted Y position
            var body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.set(0, 1.4, 0); // Adjusted Y position
            var head = new THREE.Mesh(headGeo, headMat);
            head.position.set(0, 2.3, 0); // Adjusted Y position
            var leftArm = new THREE.Mesh(armGeo, armMat);
            leftArm.position.set(-0.55, 1.5, 0);
            var rightArm = new THREE.Mesh(armGeo, armMat);
            rightArm.position.set(0.55, 1.5, 0);

            avatarGroup.add(leftLeg, rightLeg, body, head, leftArm, rightArm);
            scene.add(avatarGroup);
        }
        function createAvatar(username) {
            console.log('[WebRTC] Creating avatar for:', username);
            const avatar = new THREE.Group();
            const colorScheme = AVATAR_COLORS[simpleHash(username) % AVATAR_COLORS.length];

            const legMat = new THREE.MeshStandardMaterial({ color: colorScheme.leg });
            const bodyMat = new THREE.MeshStandardMaterial({ color: colorScheme.body });
            const headMat = new THREE.MeshStandardMaterial({ color: colorScheme.head });
            const armMat = new THREE.MeshStandardMaterial({ color: colorScheme.head });

            const legGeo = new THREE.BoxGeometry(0.4, 0.8, 0.4); // Shorter legs
            const bodyGeo = new THREE.BoxGeometry(0.8, 1.2, 0.4);
            const headGeo = new THREE.BoxGeometry(0.6, 0.6, 0.6);
            const armGeo = new THREE.BoxGeometry(0.3, 1.2, 0.3);

            const leftLeg = new THREE.Mesh(legGeo, legMat);
            leftLeg.position.set(-0.25, 0.4, 0); // Adjusted Y position
            const rightLeg = new THREE.Mesh(legGeo, legMat);
            rightLeg.position.set(0.25, 0.4, 0); // Adjusted Y position
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.set(0, 1.4, 0); // Adjusted Y position
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.set(0, 2.3, 0); // Adjusted Y position
            const leftArm = new THREE.Mesh(armGeo, armMat);
            leftArm.position.set(-0.55, 1.5, 0);
            const rightArm = new THREE.Mesh(armGeo, armMat);
            rightArm.position.set(0.55, 1.5, 0);

            avatar.add(leftLeg, rightLeg, body, head, leftArm, rightArm);
            scene.add(avatar);
            playerAvatars.set(username, avatar);
            console.log('[WebRTC] Avatar created and added to scene for:', username);
            return avatar;
        }
        function initHotbar() {
            var hotbar = document.getElementById('hotbar');
            hotbar.innerHTML = '';
            for (var i = 0; i < 32; i++) {
                var slot = document.createElement('div');
                slot.className = 'hot-slot';
                slot.dataset.index = i;
                var label = document.createElement('div');
                label.className = 'hot-label';
                var count = document.createElement('div');
                count.className = 'hot-count';
                slot.appendChild(label);
                slot.appendChild(count);
                hotbar.appendChild(slot);
                slot.addEventListener('click', function () {
                    document.querySelectorAll('.hot-slot').forEach(function (x) { x.classList.remove('active'); });
                    this.classList.add('active');
                    selectedHotIndex = parseInt(this.dataset.index);
                    updateHotbarUI();
                });
                slot.addEventListener('contextmenu', function (e) {
                    e.preventDefault();
                    if (INVENTORY[this.dataset.index] && INVENTORY[this.dataset.index].count > 0) {
                        trashIndex = this.dataset.index;
                        document.getElementById('trashItemName').innerText = 'Trash ' + BLOCKS[INVENTORY[trashIndex].id].name + ' x' + INVENTORY[trashIndex].count + ' ? ';
                        document.getElementById('trashConfirm').style.display = 'block';
                    }
                });
            }
            updateHotbarUI();
        }
        function updateHotbarUI() {
            var hotbar = document.getElementById('hotbar');
            var slots = hotbar.querySelectorAll('.hot-slot');
            slots.forEach(function (s, idx) {
                var item = INVENTORY[idx];
                var id = item ? item.id : null;
                var count = item ? item.count : 0;
                var color = id && BLOCKS[id] ? hexToRgb(BLOCKS[id].color) : [0, 0, 0];
                s.style.background = 'rgba(' + color.join(',') + ', ' + (id ? 0.45 : 0.2) + ')';
                s.querySelector('.hot-label').innerText = id && BLOCKS[id] ? BLOCKS[id].name : '';
                s.querySelector('.hot-count').innerText = count > 0 ? count : '';
                s.classList.toggle('active', idx === selectedHotIndex);
            });
            selectedBlockId = INVENTORY[selectedHotIndex] ? INVENTORY[selectedHotIndex].id : null;
            var slotWidth = 56 + 8;
            hotbar.scrollLeft = (selectedHotIndex - 4) * slotWidth;
        }
        function addToInventory(id, count) {
            for (var i = 0; i < INVENTORY.length; i++) {
                if (INVENTORY[i] && INVENTORY[i].id === id && INVENTORY[i].count < 64) {
                    var space = 64 - INVENTORY[i].count;
                    INVENTORY[i].count += Math.min(count, space);
                    count -= space;
                    updateHotbarUI();
                    if (count <= 0) return;
                }
            }
            for (var i = 0; i < INVENTORY.length; i++) {
                if (!INVENTORY[i] || INVENTORY[i].count === 0) {
                    INVENTORY[i] = { id: id, count: Math.min(count, 64) };
                    count -= 64;
                    updateHotbarUI();
                    if (count <= 0) return;
                }
            }
            addMessage('Inventory full');
        }
        function hexToRgb(hex) {
            hex = hex.replace('#', '');
            var r = parseInt(hex.substring(0, 2), 16);
            var g = parseInt(hex.substring(2, 4), 16);
            var b = parseInt(hex.substring(4, 6), 16);
            return [r, g, b];
        }
        var trashIndex = -1;
        document.getElementById('trashCancel').addEventListener('click', function () {
            document.getElementById('trashConfirm').style.display = 'none';
            trashIndex = -1;
        });
        document.getElementById('trashOk').addEventListener('click', function () {
            if (trashIndex >= 0) {
                INVENTORY[trashIndex] = null;
                updateHotbarUI();
                addMessage('Item trashed');
            }
            document.getElementById('trashConfirm').style.display = 'none';
            trashIndex = -1;
        });
        function attemptCraft(recipe) {
            var need = Object.assign({}, recipe.requires);
            var consumed = [];
            for (var i = 0; i < INVENTORY.length; i++) {
                var s = INVENTORY[i];
                if (!s || s.count === 0) continue;
                if (need[s.id]) {
                    var take = Math.min(s.count, need[s.id]);
                    need[s.id] -= take;
                    consumed.push({ slot: i, take: take });
                    if (need[s.id] <= 0) delete need[s.id];
                }
            }
            if (Object.keys(need).length > 0) {
                addMessage('Missing materials');
                return;
            }
            for (var c of consumed) {
                INVENTORY[c.slot].count -= c.take;
                if (INVENTORY[c.slot].count <= 0) INVENTORY[c.slot] = null;
            }
            addToInventory(recipe.out.id, recipe.out.count);
            addMessage('Crafted ' + BLOCKS[recipe.out.id].name);
            updateHotbarUI();
        }
        function openCrafting() {
            isPromptOpen = true;
            var m = document.getElementById('craftModal');
            m.style.display = 'block';
            var list = document.getElementById('recipeList');
            list.innerHTML = '';
            for (var r of RECIPES) {
                var row = document.createElement('div');
                row.style.display = 'flex';
                row.style.gap = '8px';
                row.style.alignItems = 'center';
                row.style.marginTop = '8px';
                var info = document.createElement('div');
                info.innerText = BLOCKS[r.out.id].name + ' x' + r.out.count;
                var reqs = document.createElement('div');
                reqs.style.opacity = 0.85;
                reqs.innerText = 'Requires: ' + Object.entries(r.requires).map(function (kv) { return (BLOCKS[kv[0]].name || kv[0]) + ' x' + kv[1]; }).join(', ');
                var btn = document.createElement('button');
                btn.innerText = 'Craft';
                btn.onclick = function () { attemptCraft(r); };
                row.appendChild(info);
                row.appendChild(reqs);
                row.appendChild(btn);
                list.appendChild(row);
            }
        }
        function safePlayAudio(audioElement) {
            if (!audioElement) return;
            var playPromise = audioElement.play();
            if (playPromise !== undefined) {
                playPromise.catch(function (e) {
                    if (!audioErrorLogged) {
                        addMessage('Audio playback issue detected', 3000);
                        audioErrorLogged = true;
                    }
                });
            }
        }
        function handleMobHit(mob) {
            // This function is only for the local player's attack action.
            // The server/host will be the one to actually process the damage.
            if (isHost) {
                mob.hurt(4, userName); // Host hits a mob, passing their own name as the attacker
            } else {
                // Client sends hit notification to its peer (the host).
                for (const [peerUser, peerData] of peers.entries()) {
                    if (peerData.dc && peerData.dc.readyState === 'open') {
                        console.log(`[WebRTC] Sending mob_hit to host ${peerUser}`);
                        peerData.dc.send(JSON.stringify({
                            type: 'mob_hit',
                            id: mob.id,
                            damage: 4,
                            username: userName // Let the host know who is attacking
                        }));
                    }
                }
            }
            safePlayAudio(soundHit); // Play sound locally for responsiveness
            addMessage('Hit mob!', 800); // Give local feedback
        }

        function onPointerDown(e) {
            if (cameraMode !== 'first') return;
            e.preventDefault();
            raycaster.setFromCamera(pointer, camera);
            raycaster.far = 5;
            var mobHits = mobs.map(function (m) { return { mob: m, intersect: raycaster.intersectObject(m.mesh)[0] }; })
                .filter(function (h) { return h.intersect; })
                .sort(function (a, b) { return a.intersect.distance - b.intersect.distance; });
            if (mobHits.length > 0) {
                var mob = mobHits[0].mob;
                handleMobHit(mob);
                return;
            }
            var ints = raycaster.intersectObject(meshGroup, true);
            if (ints.length === 0) return;
            var h = ints[0];
            var p = h.point;
            var norm = h.face.normal;
            var wx = Math.round(p.x - norm.x * 0.01);
            var wy = Math.round(p.y - norm.y * 0.01);
            var wz = Math.round(p.z - norm.z * 0.01);
            if (e.button === 0) {
                animateAttack();
                removeBlockAt(wx, wy, wz);
                safePlayAudio(soundBreak);
            } else if (e.button === 2) {
                var placeX = Math.round(p.x + norm.x * 0.51);
                var placeY = Math.round(p.y + norm.y * 0.51);
                var placeZ = Math.round(p.z + norm.z * 0.51);
                placeBlockAt(placeX, placeY, placeZ, selectedBlockId);
            }
        }
        function attackAtPoint(point) {
            for (var m of mobs) {
                if (m.mesh.position.distanceTo(point) < 1.5) {
                    handleMobHit(m);
                    return true;
                }
            }
            return false;
        }
        function removeBlockAt(wx, wy, wz) {
            var b = getBlockAt(wx, wy, wz);
            if (!b || b === BLOCK_AIR || b === 1 || b === 6) {
                addMessage('Cannot break that block');
                return;
            }
            var cx = Math.floor(modWrap(wx, MAP_SIZE) / CHUNK_SIZE);
            var cz = Math.floor(modWrap(wz, MAP_SIZE) / CHUNK_SIZE);
            var chunkKey = makeChunkKey(worldName, cx, cz);
            var canEdit = checkChunkOwnership(chunkKey, userName);
            if (!canEdit) {
                addMessage('Cannot break block in chunk ' + chunkKey + ': owned by another user');
                return;
            }
            chunkManager.setBlockGlobal(wx, wy, wz, BLOCK_AIR, userName);
            addToInventory(b, 1);
            addMessage('Picked up ' + (BLOCKS[b] ? BLOCKS[b].name : b));
            safePlayAudio(soundBreak);
        }
        function placeBlockAt(wx, wy, wz, bid) {
            if (!bid) {
                addMessage('No item selected');
                return;
            }
            var item = INVENTORY[selectedHotIndex];
            if (!item || item.id !== bid || item.count <= 0) {
                addMessage('No item to place');
                return;
            }
            var dist = Math.hypot(player.x - wx, player.y - wy, player.z - wz);
            if (dist > 5) {
                addMessage('Too far to place');
                return;
            }
            var cur = getBlockAt(wx, wy, wz);
            if (cur !== BLOCK_AIR && cur !== 6) {
                addMessage('Cannot place here');
                return;
            }
            if (checkCollisionWithPlayer(wx, wy, wz)) {
                addMessage('Cannot place inside player');
                return;
            }
            for (var m of mobs) {
                if (Math.abs(m.pos.x - wx) < 0.9 && Math.abs(m.pos.y - wy) < 0.9 && Math.abs(m.pos.z - wz) < 0.9) {
                    addMessage('Cannot place inside mob');
                    return;
                }
            }
            var cx = Math.floor(modWrap(wx, MAP_SIZE) / CHUNK_SIZE);
            var cz = Math.floor(modWrap(wz, MAP_SIZE) / CHUNK_SIZE);
            var chunkKey = makeChunkKey(worldName, cx, cz);
            var canEdit = checkChunkOwnership(chunkKey, userName);
            if (!canEdit) {
                addMessage('Cannot place block in chunk ' + chunkKey + ': owned by another user');
                return;
            }
            chunkManager.setBlockGlobal(wx, wy, wz, bid, userName);
            item.count -= 1;
            if (item.count <= 0) INVENTORY[selectedHotIndex] = null;
            addMessage('Placed ' + (BLOCKS[bid] ? BLOCKS[bid].name : bid));
            updateHotbarUI();
            safePlayAudio(soundPlace);
        }
        function checkCollisionWithPlayer(wx, wy, wz) {
            var minX = player.x - player.width / 2;
            var maxX = player.x + player.width / 2;
            var minY = player.y;
            var maxY = player.y + player.height;
            var minZ = player.z - player.width / 2;
            var maxZ = player.z + player.width / 2;
            return wx >= minX && wx <= maxX && wy >= minY && wy <= maxY && wz >= minZ && wz <= maxZ;
        }
        function getBlockAt(wx, wy, wz) {
            var wrappedWx = modWrap(Math.floor(wx), MAP_SIZE);
            var wrappedWz = modWrap(Math.floor(wz), MAP_SIZE);
            var cx = Math.floor(wrappedWx / CHUNK_SIZE);
            var cz = Math.floor(wrappedWz / CHUNK_SIZE);
            var chunk = chunkManager.getChunk(cx, cz);
            if (!chunk.generated) chunkManager.generateChunk(chunk);
            var lx = Math.floor(wrappedWx % CHUNK_SIZE);
            var lz = Math.floor(wrappedWz % CHUNK_SIZE);
            return chunk.get(lx, wy, lz);
        }
        function handlePlayerDeath() {
            if (!deathScreenShown) {
                document.getElementById('deathScreen').style.display = 'flex';
                INVENTORY = new Array(32).fill(null);
                player.score = 0;
                var scoreElement = document.getElementById('score');
                if (scoreElement) scoreElement.innerText = player.score;
                player.health = 0;
                updateHealthBar();
                updateHotbarUI();
                addMessage('You died! All items and score lost.', 5000);
                deathScreenShown = true;
            }
        }
        function respawnPlayer(x, y, z) {
            var targetX = modWrap(x || spawnPoint.x, MAP_SIZE);
            var targetZ = modWrap(z || spawnPoint.z, MAP_SIZE);
            var targetY = y || 100;
            if (!checkCollision(targetX, targetY, targetZ)) {
                player.x = targetX;
                player.y = targetY;
                player.z = targetZ;
                player.vy = 0;
                player.onGround = false;
                player.health = 20;
                player.yaw = 0;
                player.pitch = 0;
            } else {
                var found = false;
                for (var dy = 0; dy <= 5; dy++) {
                    if (!checkCollision(targetX, targetY + dy, targetZ)) {
                        player.x = targetX;
                        player.y = targetY + dy;
                        player.z = targetZ;
                        player.vy = 0;
                        player.onGround = false;
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    player.x = targetX;
                    player.y = chunkManager.getSurfaceY(targetX, targetZ) + 1;
                    player.z = targetZ;
                    player.vy = 0;
                    player.onGround = true;
                    player.health = 20;
                    player.yaw = 0;
                    player.pitch = 0;
                }
            }
            INVENTORY = new Array(32).fill(null);
            updateHotbarUI();
            updateHealthBar();
            document.getElementById('health').innerText = player.health;
            var newCx = Math.floor(targetX / CHUNK_SIZE);
            var newCz = Math.floor(targetZ / CHUNK_SIZE);
            chunkManager.preloadChunks(newCx, newCz, LOAD_RADIUS);
            for (var dx = -LOAD_RADIUS; dx <= LOAD_RADIUS; dx++) {
                for (var dz = -LOAD_RADIUS; dz <= LOAD_RADIUS; dz++) {
                    var cx = modWrap(newCx + dx, CHUNKS_PER_SIDE);
                    var cz = modWrap(newCz + dz, CHUNKS_PER_SIDE);
                    var chunk = chunkManager.getChunk(cx, cz);
                    if (!chunk.generated) chunkManager.generateChunk(chunk);
                    if (chunk.needsRebuild || !chunk.mesh) {
                        chunkManager.buildChunkMesh(chunk);
                    }
                }
            }
            chunkManager.update(player.x, player.z);
            if (cameraMode === 'first') {
                camera.position.set(player.x, player.y + 1.62, player.z);
                camera.rotation.set(0, 0, 0, 'YXZ');
                try {
                    renderer.domElement.requestPointerLock();
                    mouseLocked = true;
                    document.getElementById('crosshair').style.display = 'block';
                } catch (e) {
                    addMessage('Pointer lock failed. Serve over HTTPS or check iframe permissions.', 3000);
                }
            } else {
                camera.position.set(player.x, player.y + 5, player.z + 10);
                controls.target.set(player.x, player.y + 0.6, player.z);
                controls.update();
            }
            document.getElementById('deathScreen').style.display = 'none';
            deathScreenShown = false;
            addMessage('Respawned at ' + Math.floor(targetX) + ', ' + Math.floor(player.y) + ', ' + Math.floor(targetZ), 3000);
            for (var peer of peers) {
                var peerUser = peer[0];
                var peerData = peer[1];
                if (peerData.dc && peerData.dc.readyState === 'open') {
                    peerData.dc.send(JSON.stringify({
                        type: 'player_move',
                        username: userName,
                        x: player.x,
                        y: player.y,
                        z: player.z,
                        yaw: player.yaw,
                        pitch: player.pitch
                    }));
                }
            }
        }
        function Mob(x, z, id) {
            this.id = id || Date.now();
            this.pos = new THREE.Vector3(x, chunkManager.getSurfaceY(x, z) + 1, z);
            this.hp = 6;
            this.mesh = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.9, 0.9), new THREE.MeshLambertMaterial({ color: 0x9bff9b }));
            this.mesh.position.copy(this.pos);
            this.originalColor = new THREE.Color(0x9bff9b);
            scene.add(this.mesh);
            this.speed = 0.02 + Math.random() * 0.03;
            this.attackCooldown = 0;
            this.flashEnd = 0;
        }
        Mob.prototype.update = function (dt) {
            // Only the host runs the mob AI and state changes.
            if (!isHost) {
                // On clients, just update the mesh position smoothly.
                this.mesh.position.lerp(this.pos, 0.1);
                // Update flash effect on clients too
                if (Date.now() < this.flashEnd) {
                    this.mesh.material.color.set(0xff0000);
                } else {
                    this.mesh.material.color.copy(this.originalColor);
                }
                return;
            }

            this.pos.y = chunkManager.getSurfaceY(this.pos.x, this.pos.z) + Math.sin(Date.now() * 0.003 + this.mesh.id) * 0.4 + 0.5;

            // Find the closest player to target
            let closestPlayer = null;
            let minDistance = Infinity;

            // Consider the host player
            let hostDist = Math.hypot(player.x - this.pos.x, player.z - this.pos.z);
            if (hostDist < minDistance) {
                minDistance = hostDist;
                closestPlayer = { x: player.x, z: player.z, health: player.health, username: userName };
            }

            // Consider all connected peers
            for (const [username, peerData] of peers.entries()) {
                if (userPositions[username]) {
                    const peerPos = userPositions[username];
                    const dist = Math.hypot(peerPos.x - this.pos.x, peerPos.z - this.pos.z);
                    if (dist < minDistance) {
                        minDistance = dist;
                        closestPlayer = { x: peerPos.x, z: peerPos.z, health: 20, username: username }; // Assume full health for peers for now
                    }
                }
            }

            if (closestPlayer && minDistance < 10) {
                const dx = closestPlayer.x - this.pos.x;
                const dz = closestPlayer.z - this.pos.z;
                const vx = dx / minDistance * this.speed;
                const vz = dz / minDistance * this.speed;
                const newX = modWrap(this.pos.x + vx * dt * 60, MAP_SIZE);
                const newZ = modWrap(this.pos.z + vz * dt * 60, MAP_SIZE);

                if (!checkCollisionWithBlock(newX, this.pos.y, newZ) && !checkCollisionWithPlayer(newX, this.pos.y, newZ)) {
                    this.pos.x = newX;
                    this.pos.z = newZ;
                }

                if (minDistance < 1.2 && Date.now() - this.attackCooldown > 800) {
                    this.attackCooldown = Date.now();
                    // Host sends a message to the targeted player to inflict damage
                    const targetPeer = peers.get(closestPlayer.username);
                    if (targetPeer && targetPeer.dc && targetPeer.dc.readyState === 'open') {
                        targetPeer.dc.send(JSON.stringify({ type: 'player_damage', damage: 1 }));
                    } else if (closestPlayer.username === userName) {
                        // The mob is attacking the host player
                        if (Date.now() - lastDamageTime > 800) {
                            player.health = Math.max(0, player.health - 1);
                            lastDamageTime = Date.now();
                            document.getElementById('health').innerText = player.health;
                            updateHealthBar();
                            addMessage('Hit! HP: ' + player.health, 1000);
                            if (player.health <= 0) {
                                handlePlayerDeath();
                            }
                        }
                    }
                }
            } else {
                // Wander aimlessly if no player is near
                const newX = modWrap(this.pos.x + (Math.sin(Date.now() * 0.001 + this.mesh.id) * 0.002) * dt * 60, MAP_SIZE);
                const newZ = modWrap(this.pos.z + (Math.cos(Date.now() * 0.001 + this.mesh.id) * 0.002) * dt * 60, MAP_SIZE);
                if (!checkCollisionWithBlock(newX, this.pos.y, newZ) && !checkCollisionWithPlayer(newX, this.pos.y, newZ)) {
                    this.pos.x = newX;
                    this.pos.z = newZ;
                }
            }

            this.mesh.position.copy(this.pos);

            // Host broadcasts the mob's state to all clients.
            const updateMessage = JSON.stringify({
                type: 'mob_update',
                id: this.id,
                x: this.pos.x,
                y: this.pos.y,
                z: this.pos.z,
                hp: this.hp
            });

            for (const [peerUser, peerData] of peers.entries()) {
                if (peerUser !== userName && peerData.dc && peerData.dc.readyState === 'open') {
                    peerData.dc.send(updateMessage);
                }
            }
        };
        Mob.prototype.hurt = function (dmg, attackerName) {
            if (!isHost) return; // Only host can process damage

            this.hp -= dmg;
            this.flashEnd = Date.now() + 200; // Trigger flash effect
            safePlayAudio(soundHit);

            if (this.hp <= 0) {
                this.die(attackerName);
            } else {
                // Broadcast the health update
                const updateMessage = JSON.stringify({
                    type: 'mob_update',
                    id: this.id,
                    x: this.pos.x,
                    y: this.pos.y,
                    z: this.pos.z,
                    hp: this.hp,
                    flash: true // Tell clients to trigger the flash
                });
                for (const [peerUser, peerData] of peers.entries()) {
                    if (peerUser !== userName && peerData.dc && peerData.dc.readyState === 'open') {
                        peerData.dc.send(updateMessage);
                    }
                }
            }
        };
        Mob.prototype.die = function (killerName) {
            if (!isHost) return; // Only host can process death

            try {
                scene.remove(this.mesh);
                disposeObject(this.mesh);
            } catch (e) {}

            mobs = mobs.filter(m => m.id !== this.id);
            addMessage('Mob defeated!');

            // Award score to the killer
            if (killerName === userName) {
                player.score += 10;
                document.getElementById('score').innerText = player.score;
                addMessage('+10 score');
            } else {
                const killerPeer = peers.get(killerName);
                if (killerPeer && killerPeer.dc && killerPeer.dc.readyState === 'open') {
                    killerPeer.dc.send(JSON.stringify({ type: 'add_score', amount: 10 }));
                }
            }

            // Broadcast the kill to all clients
            const killMessage = JSON.stringify({ type: 'mob_kill', id: this.id });
            for (const [peerUser, peerData] of peers.entries()) {
                 if (peerUser !== userName && peerData.dc && peerData.dc.readyState === 'open') {
                    peerData.dc.send(killMessage);
                }
            }
        };
        function spawnMobs(count, rnd) {
            if (!isHost) return; // Only the host can spawn mobs.
            if (!rnd) {
                console.error("No seeded random generator provided for mob spawning.");
                return;
            }

            var loadedChunks = Array.from(chunkManager.chunks.keys());
            if (loadedChunks.length === 0) return;
            for (var i = 0; i < count; i++) {
                var randomChunkKey = loadedChunks[Math.floor(rnd() * loadedChunks.length)];
                var parsed = parseChunkKey(randomChunkKey);
                if (!parsed) continue;
                var cx = parsed.cx;
                var cz = parsed.cz;
                var baseX = cx * CHUNK_SIZE;
                var baseZ = cz * CHUNK_SIZE;
                var lx = rnd() * CHUNK_SIZE;
                var lz = rnd() * CHUNK_SIZE;
                var x = modWrap(baseX + lx, MAP_SIZE);
                var z = modWrap(baseZ + lz, MAP_SIZE);
                var m = new Mob(x, z);
                mobs.push(m);
            }
        }
        function isSolid(id) {
            return id !== 0 && id !== 6 && id !== 12 && id !== 8 && id !== 16 && id !== 17 && id !== 100 && id !== 101 && id !== 102 && id !== 103 && id !== 104 && id !== 111 && id !== 112 && id !== 113 && id !== 114 && id !== 116 && id !== 117;
        }
        function checkCollisionWithBlock(newX, newY, newZ) {
            var minX = newX - 0.45;
            var minY = newY;
            var minZ = newZ - 0.45;
            var maxX = newX + 0.45;
            var maxY = newY + 0.9;
            var maxZ = newZ + 0.45;
            for (var bx = Math.floor(minX); bx <= Math.floor(maxX); bx++) {
                for (var by = Math.floor(minY); by <= Math.floor(maxY); by++) {
                    for (var bz = Math.floor(minZ); bz <= Math.floor(maxZ); bz++) {
                        if (isSolid(getBlockAt(bx, by, bz))) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        function checkCollision(newX, newY, newZ) {
            var minX = newX - player.width / 2 + 0.001;
            var minY = newY + 0.001;
            var maxX = newX + player.width / 2 - 0.001;
            var maxY = newY + player.height - 0.001;
            var minZ = newZ - player.width / 2 + 0.001;
            var maxZ = newZ + player.width / 2 - 0.001;
            for (var bx = Math.floor(minX); bx <= Math.floor(maxX); bx++) {
                for (var by = Math.floor(minY); by <= Math.floor(maxY); by++) {
                    for (var bz = Math.floor(minZ); bz <= Math.floor(maxZ); bz++) {
                        if (isSolid(getBlockAt(bx, by, bz))) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        function pushPlayerOut() {
            var directions = [
                { dx: 0.2, dz: 0 }, { dx: -0.2, dz: 0 }, { dx: 0, dz: 0.2 }, { dx: 0, dz: -0.2 },
                { dx: 0.2, dz: 0.2 }, { dx: 0.2, dz: -0.2 }, { dx: -0.2, dz: 0.2 }, { dx: -0.2, dz: -0.2 }
            ];
            for (var yOffset = 0; yOffset <= 2; yOffset += 0.2) {
                for (var dir of directions) {
                    var newX = modWrap(player.x + dir.dx, MAP_SIZE);
                    var newZ = modWrap(player.z + dir.dz, MAP_SIZE);
                    var newY = player.y + yOffset;
                    if (!checkCollision(newX, newY, newZ)) {
                        player.x = newX;
                        player.y = newY;
                        player.z = newZ;
                        player.vy = 0;
                        player.onGround = true;
                        addMessage('Pushed out of block');
                        return true;
                    }
                }
            }
            return false;
        }
        var minimapCtx;
        // Description: Handles file upload via double-click or drag-and-drop on the minimap.
        // If the file is an offer JSON, it adds it to pendingOffers and opens the pending connections modal (server mode).
        // If the file is an answer JSON, it processes it to establish a connection (client mode).
        async function handleMinimapFile(file) {
    try {
        const text = await file.text();
        const data = JSON.parse(text);
        if (!data.world || data.world !== worldName) {
            addMessage('Invalid file: wrong world', 3000);
            console.log('[WebRTC] Invalid file: world mismatch, expected:', worldName, 'got:', data.world);
            return;
        }
        if (data.offer && isHost) {
            // ... (unchanged)
        } else if (data.answer && !isHost) {
            // Client mode: Process answer
            const hostUser = data.user || 'anonymous';
            const peer = peers.get(hostUser);
            if (!peer || !peer.pc) {
                addMessage('No active connection for ' + hostUser, 3000);
                console.log('[WebRTC] No peer connection for:', hostUser);
                return;
            }
            if (peer.pc.signalingState !== 'have-local-offer') {
                console.log('[WebRTC] Skipping answer processing, wrong state:', peer.pc.signalingState);
                addMessage('Connection already processed or in wrong state', 3000);
                return;
            }
            try {
                await peer.pc.setRemoteDescription(new RTCSessionDescription(data.answer));
                for (const candidate of data.iceCandidates || []) {
                    try {
                        await peer.pc.addIceCandidate(new RTCIceCandidate(candidate));
                    } catch (e) {
                        console.error('[WebRTC] Failed to add ICE candidate for:', hostUser, 'error:', e);
                    }
                }
                console.log('[WebRTC] Successfully processed answer for:', hostUser);
                addMessage('Connected to ' + hostUser + ' via file', 5000);
                updateHudButtons();
                clearInterval(answerPollingIntervals.get('MCAnswer@' + userName + '@' + worldName));
                answerPollingIntervals.delete('MCAnswer@' + userName + '@' + worldName);
            } catch (e) {
                console.error('[WebRTC] Failed to process answer for:', hostUser, 'error:', e);
                addMessage('Failed to connect to ' + hostUser, 3000);
            }
        } else if (data.batch && !isHost) {
            // Client mode: Process batch answer
            const hostUser = data.user || 'anonymous';
            const peer = peers.get(hostUser);
            if (!peer || !peer.pc) {
                addMessage('No active connection for ' + hostUser, 3000);
                console.log('[WebRTC] No peer connection for:', hostUser);
                return;
            }
            const answerEntry = data.batch.find(entry => entry.user === userName);
            if (!answerEntry) {
                addMessage('No answer for you in batch from ' + hostUser, 3000);
                console.log('[WebRTC] No answer for user:', userName, 'in batch from:', hostUser);
                return;
            }
            if (peer.pc.signalingState !== 'have-local-offer') {
                console.log('[WebRTC] Skipping batch answer processing, wrong state:', peer.pc.signalingState);
                addMessage('Connection already processed or in wrong state', 3000);
                return;
            }
            try {
                await peer.pc.setRemoteDescription(new RTCSessionDescription(answerEntry.answer));
                for (const candidate of answerEntry.iceCandidates || []) {
                    try {
                        await peer.pc.addIceCandidate(new RTCIceCandidate(candidate));
                    } catch (e) {
                        console.error('[WebRTC] Failed to add ICE candidate for:', hostUser, 'error:', e);
                    }
                }
                console.log('[WebRTC] Successfully processed batch answer for:', hostUser);
                addMessage('Connected to ' + hostUser + ' via batch file', 5000);
                updateHudButtons();
                clearInterval(answerPollingIntervals.get('MCAnswer@' + userName + '@' + worldName));
                answerPollingIntervals.delete('MCAnswer@' + userName + '@' + worldName);
            } catch (e) {
                console.error('[WebRTC] Failed to process batch answer for:', hostUser, 'error:', e);
                addMessage('Failed to connect to ' + hostUser, 3000);
            }
        } else {
            addMessage('Invalid file format', 3000);
            console.log('[WebRTC] Invalid file: no offer, answer, or batch');
        }
    } catch (e) {
        console.error('[WebRTC] Error processing file:', e);
        addMessage('Failed to process file', 3000);
    }
}
        function updateMinimap() {
            if (!minimapCtx) return;
            var canvas = minimapCtx.canvas;
            minimapCtx.clearRect(0, 0, canvas.width, canvas.height);
            minimapCtx.fillStyle = 'rgba(0,0,0,0.3)';
            minimapCtx.fillRect(0, 0, canvas.width, canvas.height);
            var scale = canvas.width / 40;
            var cx = canvas.width / 2;
            var cz = canvas.height / 2;
            minimapCtx.fillStyle = '#ffffff';
            minimapCtx.fillRect(cx - 2, cz - 2, 4, 4);
            minimapCtx.fillStyle = '#9bff9b';
            for (var m of mobs) {
                var dx = m.pos.x - player.x;
                var dz = m.pos.z - player.z;
                if (Math.abs(dx) <= 20 && Math.abs(dz) <= 20) {
                    var px = cx + dx * scale;
                    var pz = cz + dz * scale;
                    minimapCtx.fillRect(px - 2, pz - 2, 4, 4);
                }
            }
            minimapCtx.fillStyle = '#ff6b6b';
            for (var entry of playerAvatars) {
                var username = entry[0];
                var avatar = entry[1];
                var dx = avatar.position.x - player.x;
                var dz = avatar.position.z - player.z;
                if (Math.abs(dx) <= 20 && Math.abs(dz) <= 20) {
                    var px = cx + dx * scale;
                    var pz = cz + dz * scale;
                    minimapCtx.fillRect(px - 2, pz - 2, 4, 4);
                }
            }
        }
        var keys = {};
        function registerKeyEvents() {
            function keydownHandler(e) {
                keys[e.key.toLowerCase()] = true;
                if (e.key === 'Escape' && mouseLocked) {
                    document.exitPointerLock();
                    mouseLocked = false;
                }
                if (e.key.toLowerCase() === 't') toggleCameraMode();
                if (e.key.toLowerCase() === 'r') openCrafting();
                if (e.key.toLowerCase() === 'p') {
                    isPromptOpen = true;
                    document.getElementById('teleportModal').style.display = 'block';
                    document.getElementById('teleportX').value = '';
                    document.getElementById('teleportY').value = '';
                    document.getElementById('teleportZ').value = '';
                }
                if (e.key.toLowerCase() === 'x' && CHUNK_DELTAS.size > 0) downloadSession();
                if (e.key.toLowerCase() === 'u') openUsersModal();
                if (e.key.toLowerCase() === ' ') {
                    playerJump();
                    safePlayAudio(soundJump);
                }
            }
            function keyupHandler(e) { keys[e.key.toLowerCase()] = false; }
            window.addEventListener('keydown', keydownHandler);
            window.addEventListener('keyup', keyupHandler);
            return function () {
                window.removeEventListener('keydown', keydownHandler);
                window.removeEventListener('keyup', keyupHandler);
            };
        }
        function playerJump() {
            if (player.onGround) {
                player.vy = 8.5;
                player.onGround = false;
                safePlayAudio(soundJump);
            }
        }
        function toggleCameraMode() {
            cameraMode = (cameraMode === 'third') ? 'first' : 'third';
            addMessage('Camera: ' + cameraMode);
            controls.enabled = cameraMode === 'third';
            avatarGroup.visible = cameraMode === 'third';
            if (cameraMode === 'third') {
                camera.position.set(player.x, player.y + 5, player.z + 10);
                controls.target.set(player.x, player.y + 0.6, player.z);
                controls.update();
                if (!isMobile()) {
                    document.exitPointerLock();
                }
                mouseLocked = false;
                document.getElementById('crosshair').style.display = 'none';
            } else {
                if (!isMobile()) {
                    try {
                        renderer.domElement.requestPointerLock();
                        mouseLocked = true;
                        document.getElementById('crosshair').style.display = 'block';
                    } catch (e) {
                        addMessage('Pointer lock failed. Please serve over HTTPS or ensure allow-pointer-lock is set in iframe.');
                        document.getElementById('crosshair').style.display = 'block';
                    }
                } else {
                    document.getElementById('crosshair').style.display = 'block';
                }
                player.yaw = 0;
                player.pitch = 0;
                camera.rotation.set(0, 0, 0, 'YXZ');
            }
        }
        function performAttack() {
            animateAttack();
            var dir = new THREE.Vector3();
            camera.getWorldDirection(dir);
            var origin = (cameraMode === 'first') ? new THREE.Vector3(player.x, player.y + 1.62, player.z) : camera.position.clone();
            raycaster.setFromCamera(pointer, camera);
            raycaster.far = 5;
            var mobHits = mobs.map(function (m) { return { mob: m, intersect: raycaster.intersectObject(m.mesh)[0] }; })
                .filter(function (h) { return h.intersect; })
                .sort(function (a, b) { return a.intersect.distance - b.intersect.distance; });
            if (mobHits.length > 0) {
                var mob = mobHits[0].mob;
                mob.hurt(4);
                safePlayAudio(soundHit);
                addMessage('Hit mob!', 800);
                return;
            }
            for (var d = 0.6; d < 3.0; d += 0.6) {
                var p = origin.clone().addScaledVector(dir, d);
                var bx = Math.round(p.x), by = Math.round(p.y), bz = Math.round(p.z);
                var b = getBlockAt(bx, by, bz);
                if (b && b !== BLOCK_AIR && b !== 6) {
                    removeBlockAt(bx, by, bz);
                    return;
                }
            }
        }
        async function downloadSession() {
            var out = {
                world: worldName,
                seed: worldSeed,
                user: userName,
                savedAt: new Date().toISOString(),
                deltas: [],
                profile: {
                    x: player.x,
                    y: player.y,
                    z: player.z,
                    inventory: INVENTORY
                }
            };
            for (var entry of CHUNK_DELTAS) {
                var k = entry[0];
                var arr = entry[1];
                var parsed = parseChunkKey(k);
                if (parsed) {
                    out.deltas.push({ chunk: k, changes: arr });
                }
            }
            var blob = new Blob([JSON.stringify(out)], { type: 'application/json' });
            var url = URL.createObjectURL(blob);
            var a = document.createElement('a');
            a.href = url;
            a.download = worldName + '_session_' + Date.now() + '.json';
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);
            addMessage('Session downloaded');
            var chunkKeys = Array.from(CHUNK_DELTAS.keys());
            var chunkAddresses = await Promise.all(chunkKeys.map(async function (key) {
                var addr = await GetPublicAddressByKeyword(key);
                return addr ? addr.trim().replace(/^"|"$/g, '') : key;
            }));
            document.getElementById('downloadAddressList').value = chunkAddresses.join(',');
            document.getElementById('downloadModal').style.display = 'block';
        }
        function disposeObject(obj) {
            obj.traverse(function (c) {
                if (c.geometry) c.geometry.dispose();
                if (c.material) {
                    if (Array.isArray(c.material)) c.material.forEach(function (m) { m.dispose(); });
                    else c.material.dispose();
                }
            });
        }
        function addMessage(txt, ttl) {
            var c = document.getElementById('messages');
            var el = document.createElement('div');
            el.className = 'msg';
            el.innerText = txt;
            c.prepend(el);
            setTimeout(function () { el.remove(); }, ttl || 2000);
        }
        function updateHealthBar() {
            var pct = Math.max(0, Math.min(1, player.health / 20));
            document.getElementById('healthBarInner').style.width = (pct * 100) + '%';
        }
        function updateSaveChangesButton() {
            var saveBtn = document.getElementById('saveChangesBtn');
            saveBtn.style.display = CHUNK_DELTAS.size > 0 ? 'inline-block' : 'none';
        }
        function updateHudButtons() {
            var joinScriptBtn = document.getElementById('joinScriptBtn');
            joinScriptBtn.style.display = 'none';
            updateSaveChangesButton();
            var usersBtn = document.getElementById('usersBtn');
            var peerCount = peers.size > 0 ? peers.size - (peers.has(userName) ? 1 : 0) : 0;
            console.log('[WebRTC] Updating usersBtn: peerCount=', peerCount, 'peers=', Array.from(peers.keys()));
            usersBtn.style.display = 'inline-block';
            usersBtn.innerText = '🌐 ' + peerCount;
            usersBtn.onclick = function () {
                console.log('[Modal] usersBtn clicked, opening modal');
                openUsersModal();
            };
            setupPendingModal();
        }
        function updateHud() {
            var scoreElement = document.getElementById('score');
            if (scoreElement) scoreElement.innerText = player.score;
            var healthElement = document.getElementById('health');
            if (healthElement) healthElement.innerText = player.health;
            var posLabel = document.getElementById('posLabel');
            if (posLabel) posLabel.innerText = Math.floor(player.x) + ', ' + Math.floor(player.y) + ', ' + Math.floor(player.z);
            var distFromSpawn = Math.hypot(player.x - spawnPoint.x, player.z - spawnPoint.z);
            document.getElementById('homeIcon').style.display = distFromSpawn > 10 ? 'inline' : 'none';
            updateHealthBar();
            updateHotbarUI();
            updateHudButtons();
        }
        function isMobile() { return /Android|iPhone|iPad|Mobi/i.test(navigator.userAgent); }
        function setupMobile() {
            if (!isMobile()) return;
            var up = document.getElementById('mUp'), down = document.getElementById('mDown'), left = document.getElementById('mLeft'), right = document.getElementById('mRight');
            up.addEventListener('touchstart', function (e) { joystick.up = true; e.preventDefault(); });
            up.addEventListener('touchend', function (e) { joystick.up = false; e.preventDefault(); });
            down.addEventListener('touchstart', function (e) { joystick.down = true; e.preventDefault(); });
            down.addEventListener('touchend', function (e) { joystick.down = false; e.preventDefault(); });
            left.addEventListener('touchstart', function (e) { joystick.left = true; e.preventDefault(); });
            left.addEventListener('touchend', function (e) { joystick.left = false; e.preventDefault(); });
            right.addEventListener('touchstart', function (e) { joystick.right = true; e.preventDefault(); });
            right.addEventListener('touchend', function (e) { joystick.right = false; e.preventDefault(); });
            document.getElementById('mJump').addEventListener('touchstart', function (e) { playerJump(); safePlayAudio(soundJump); e.preventDefault(); });
            document.getElementById('mAttack').addEventListener('touchstart', function (e) { performAttack(); e.preventDefault(); });
            document.getElementById('mCam').addEventListener('touchstart', function (e) { toggleCameraMode(); e.preventDefault(); });
        }
        function updateLoginUI() {
            try {
                console.log('[Debug] updateLoginUI started, knownWorlds:', knownWorlds.size, 'knownUsers:', knownUsers.size);
                var worldInput = document.getElementById('worldNameInput');
                var userInput = document.getElementById('userInput');
                var worldSuggestions = document.getElementById('worldSuggestions');
                var userSuggestions = document.getElementById('userSuggestions');
                if (!worldInput || !userInput || !worldSuggestions || !userSuggestions) {
                    console.error('[Debug] Input or suggestion elements not found in DOM');
                    addMessage('UI initialization failed: elements missing', 3000);
                    return;
                }
                function updateWorldSuggestions() {
                    var value = worldInput.value.toLowerCase();
                    var suggestions = Array.from(knownWorlds.entries())
                        .filter(function (w) { return w[0].toLowerCase().startsWith(value); })
                        .slice(0, 10);
                    worldSuggestions.innerHTML = suggestions.map(function (w) {
                        var server = knownServers.find(function (s) { return s.hostUser === w[1].discoverer; });
                        var isOld = server ? (Date.now() - server.timestamp > 86400000) : true;
                        return '<div data-value="' + w[0] + '" class="' + (isOld ? 'greyed' : '') + '">' + w[0] + ' (' + (w[1].discoverer || 'unknown') + ')</div>';
                    }).join('');
                    worldSuggestions.style.display = suggestions.length > 0 && value ? 'block' : 'none';
                    console.log('[LoginUI] World suggestions updated:', suggestions.length);
                }
                function updateUserSuggestions() {
                    var value = userInput.value.toLowerCase();
                    var suggestions = Array.from(knownUsers.keys())
                        .filter(function (u) { return u.toLowerCase().startsWith(value); })
                        .slice(0, 10);
                    userSuggestions.innerHTML = suggestions.map(function (u) { return '<div data-value="' + u + '">' + u + '</div>'; }).join('');
                    userSuggestions.style.display = suggestions.length > 0 && value ? 'block' : 'none';
                    console.log('[LoginUI] User suggestions updated:', suggestions.length);
                }
                worldInput.addEventListener('input', updateWorldSuggestions);
                userInput.addEventListener('input', updateUserSuggestions);
                function initSuggestions() {
                    updateWorldSuggestions();
                    updateUserSuggestions();
                }
                setTimeout(initSuggestions, 1000);
                initSuggestions();
                worldSuggestions.addEventListener('click', function (e) {
                    if (e.target.dataset.value) {
                        worldInput.value = e.target.dataset.value;
                        worldSuggestions.style.display = 'none';
                        console.log('[LoginUI] Selected world:', e.target.dataset.value);
                    }
                });
                userSuggestions.addEventListener('click', function (e) {
                    if (e.target.dataset.value) {
                        userInput.value = e.target.dataset.value;
                        userSuggestions.style.display = 'none';
                        console.log('[LoginUI] Selected user:', e.target.dataset.value);
                    }
                });
                document.addEventListener('click', function (e) {
                    if (!worldInput.contains(e.target) && !worldSuggestions.contains(e.target)) {
                        worldSuggestions.style.display = 'none';
                    }
                    if (!userInput.contains(e.target) && !userSuggestions.contains(e.target)) {
                        userSuggestions.style.display = 'none';
                    }
                });
                console.log('[Debug] updateLoginUI completed');
                userSuggestions.addEventListener('click', function (e) {
                    if (e.target.dataset.value) {
                        userInput.value = e.target.dataset.value;
                        userSuggestions.style.display = 'none';
                        console.log('[LoginUI] Selected user:', e.target.dataset.value);
                    }
                });
                document.addEventListener('click', function (e) {
                    if (!worldInput.contains(e.target) && !worldSuggestions.contains(e.target)) {
                        worldSuggestions.style.display = 'none';
                    }
                    if (!userInput.contains(e.target) && !userSuggestions.contains(e.target)) {
                        userSuggestions.style.display = 'none';
                    }
                });
                console.log('[Debug] updateLoginUI completed');
            } catch (error) {
                console.error('[Debug] Error in updateLoginUI:', error);
                addMessage('Failed to initialize login UI', 3000);
            }
        }
        async function populateSpawnChunks() {
            for (var entry of spawnChunks) {
                var user = entry[0];
                var data = entry[1];
                var spawn = calculateSpawnPoint(user + '@' + data.world);
                spawnChunks.set(user, { cx: Math.floor(spawn.x / CHUNK_SIZE), cz: Math.floor(spawn.z / CHUNK_SIZE), username: data.username, world: data.world, spawn: spawn });
            }
        }
        
async function announceServer() {
    if (isHost) {
        console.log('[WebRTC] Already hosting, skipping announce for:', userName);
        addMessage('Server already announced', 3000);
        return;
    }
    if (isInitialLoad) {
        console.log('[WebRTC] Waiting for initial load to complete before announcing');
        await new Promise(resolve => {
            const check = setInterval(() => {
                if (!isInitialLoad) {
                    clearInterval(check);
                    resolve();
                }
            }, 100);
        });
    }
    const modal = document.getElementById('joinScriptModal');
    if (!modal) {
        console.error('[WebRTC] joinScriptModal not found in DOM');
        addMessage('UI error: Modal not found', 5000);
        return;
    }
    isHost = true;
    console.log('[WebRTC] Announcing server for:', userName);
    // REMOVED: pc creation and peers.set(userName, ...)
    // Open modal
    const serverKeyword = 'MCServers@' + worldName;  // Note: Your code has 'MCServerJoin@', but adjust if needed
    let serverAddr = null;
    try {
        serverAddr = await GetPublicAddressByKeyword(serverKeyword);
    } catch (e) {
        console.error('[WebRTC] Failed to fetch server address:', e);
    }
    const addressText = serverAddr ? serverAddr.trim().replace(/"|'/g, '') : serverKeyword;
    modal.querySelector('h3').innerText = 'Announce Server';
    modal.querySelector('p').innerText = `Copy this address and paste it into a Sup!? message To: field and click 📢 to announce your server.`;
    modal.querySelector('#joinScriptText').value = addressText;
    modal.style.display = 'block';
    isPromptOpen = true;
    addMessage('Server announced! Share the address to invite players.', 5000);
    console.log('[WebRTC] Join script modal opened with address:', addressText);
    // Start polling
    if (isHost) {
        const safeChunkKeys = []; // Fallback for undefined chunkKeys
        worker.postMessage({
            type: 'poll',
            chunkKeys: safeChunkKeys,
            masterKey: 'MCWorlds',
            userAddress: userAddress,
            worldName: worldName,
            serverKeyword: 'MCServerJoin@' + worldName,
            offerKeyword: 'MCConn@' + userName + '@' + worldName,
            answerKeywords: [],
            userName: userName
        });
        worker.postMessage({ type: 'sync_processed', ids: Array.from(processedMessages) });
        startOfferPolling();
    }
}

        async function connectToServer(hostUser, offer, iceCandidates) {
            if (peers.size >= MAX_PEERS) {
                addMessage('Cannot connect: too many peers.', 3000);
                console.log('[WebRTC] Connection failed: max peers reached');
                return;
            }
            var server = knownServers.find(function (s) { return s.hostUser === hostUser; });
            if (!server) {
                addMessage('No server found for ' + hostUser, 3000);
                console.log('[WebRTC] No server found for:', hostUser);
                return;
            }
            console.log('[WebRTC] Initiating connection to server:', hostUser);
            connectionAttempts.set(hostUser, Date.now());
            const iceServers = await getTurnCredentials();
            var pc = new RTCPeerConnection({ iceServers });
            var dc = pc.createDataChannel('game');
            setupDataChannel(dc, hostUser);
            try {
                var offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                var offerIceCandidates = [];
                pc.onicecandidate = function (e) {
                    if (e.candidate) offerIceCandidates.push(e.candidate);
                };
                await new Promise(function (resolve) {
                    pc.onicegatheringstatechange = function () {
                        if (pc.iceGatheringState === 'complete') resolve();
                    };
                });
                var offerData = {
                    world: worldName,
                    user: userName,
                    offer: pc.localDescription,
                    iceCandidates: offerIceCandidates
                };
                var blob = new Blob([JSON.stringify(offerData)], { type: 'application/json' });
                var url = URL.createObjectURL(blob);
                var a = document.createElement('a');
                a.href = url;
                a.download = `${worldName}_offer_${Date.now()}.json`;
                document.body.appendChild(a);
                a.click();
                a.remove();
                URL.revokeObjectURL(url);
                var responseKeyword = 'MCConn@' + hostUser + '@' + worldName;
                var responseAddr = await GetPublicAddressByKeyword(responseKeyword);
                document.getElementById('joinScriptText').value = responseAddr ? responseAddr.trim().replace(/"|'/g, '') : responseKeyword;
                document.getElementById('joinScriptModal').style.display = 'block';
                document.getElementById('joinScriptModal').querySelector('h3').innerText = 'Connect to Server';
                document.getElementById('joinScriptModal').querySelector('p').innerText = 'Copy this address and paste it into a Sup!? message To: field, attach the JSON file, and click 📢 to connect to ' + hostUser + '. After sending, wait for host confirmation.';
                addMessage('Offer created for ' + hostUser + '. Send the JSON via Sup!? and wait for host to accept.', 10000);
                peers.set(hostUser, { pc: pc, dc: dc, address: null });
                var answerKeyword = 'MCAnswer@' + userName + '@' + worldName;
                answerPollingIntervals.set(answerKeyword, setInterval(function () {
                    worker.postMessage({
                        type: 'poll',
                        chunkKeys: [],
                        masterKey: MASTER_WORLD_KEY,
                        userAddress: userAddress,
                        worldName: worldName,
                        serverKeyword: 'MCServerJoin@' + worldName,
                        offerKeyword: null,
                        answerKeywords: [answerKeyword],
                        userName: userName
                    });
                    if (Date.now() - connectionAttempts.get(hostUser) > 1800000) {
                        console.log('[WebRTC] Answer polling timeout for:', hostUser);
                        addMessage('Connection to ' + hostUser + ' timed out after 30 minutes.', 5000);
                        clearInterval(answerPollingIntervals.get(answerKeyword));
                        answerPollingIntervals.delete(answerKeyword);
                        var peer = peers.get(hostUser);
                        if (peer && peer.pc) peer.pc.close();
                        peers.delete(hostUser);
                        if (playerAvatars.has(hostUser)) {
                            scene.remove(playerAvatars.get(hostUser));
                            disposeObject(playerAvatars.get(hostUser));
                            playerAvatars.delete(hostUser);
                        }
                        delete userPositions[hostUser];
                        updateHudButtons();
                    }
                }, 30000));
            } catch (e) {
                console.error('[WebRTC] Failed to create offer for:', hostUser, 'error:', e);
                addMessage('Failed to connect to ' + hostUser, 3000);
                pc.close();
                peers.delete(hostUser);
                clearInterval(answerPollingIntervals.get('MCAnswer@' + userName + '@' + worldName));
                answerPollingIntervals.delete('MCAnswer@' + userName + '@' + worldName);
            }
        }
        // Description: Handles file upload via double-click or drag-and-drop on the minimap.
        // If the file is an offer JSON, it adds it to pendingOffers and opens the pending connections modal (server mode).
        // If the file is an answer JSON, it processes it to establish a connection (client mode).
        async function handleMinimapFile(file) {
            try {
                const text = await file.text();
                const data = JSON.parse(text);
                if (!data.world || data.world !== worldName) {
                    addMessage('Invalid file: wrong world', 3000);
                    console.log('[WebRTC] Invalid file: world mismatch, expected:', worldName, 'got:', data.world);
                    return;
                }
                if (data.offer && isHost) {
                    // Server mode: Process offer
                    const clientUser = data.user || 'anonymous';
                    if (clientUser === userName) {
                        addMessage('Cannot process offer from self', 3000);
                        console.log('[WebRTC] Skipping offer from self:', clientUser);
                        return;
                    }
                    const profile = await GetProfileByURN(clientUser);
                    pendingOffers.push({
                        clientUser: clientUser,
                        offer: data.offer,
                        iceCandidates: data.iceCandidates || [],
                        transactionId: 'local_' + Date.now(),
                        timestamp: Date.now(),
                        profile: profile || { URN: clientUser, Creators: [null] }
                    });
                    console.log('[WebRTC] Added local offer from:', clientUser);
                    addMessage(`Connection request from ${clientUser} via file`, 5000);
                    setupPendingModal();
                    document.getElementById('pendingModal').style.display = 'block';
                    isPromptOpen = true;
                } else if (data.answer && !isHost) {
                    // Client mode: Process answer
                    const hostUser = data.user || 'anonymous';
                    const peer = peers.get(hostUser);
                    if (!peer || !peer.pc) {
                        addMessage('No active connection for ' + hostUser, 3000);
                        console.log('[WebRTC] No peer connection for:', hostUser);
                        return;
                    }
                    try {
                        await peer.pc.setRemoteDescription(new RTCSessionDescription(data.answer));
                        for (const candidate of data.iceCandidates || []) {
                            try {
                                await peer.pc.addIceCandidate(new RTCIceCandidate(candidate));
                            } catch (e) {
                                console.error('[WebRTC] Failed to add ICE candidate for:', hostUser, 'error:', e);
                            }
                        }
                        console.log('[WebRTC] Successfully processed answer for:', hostUser);
                        addMessage('Connected to ' + hostUser + ' via file', 5000);
                        updateHudButtons();
                        clearInterval(answerPollingIntervals.get('MCAnswer@' + userName + '@' + worldName));
                        answerPollingIntervals.delete('MCAnswer@' + userName + '@' + worldName);
                    } catch (e) {
                        console.error('[WebRTC] Failed to process answer for:', hostUser, 'error:', e);
                        addMessage('Failed to connect to ' + hostUser, 3000);
                    }
                } else if (data.batch && !isHost) {
                    // Client mode: Process batch answer
                    const hostUser = data.user || 'anonymous';
                    const peer = peers.get(hostUser);
                    if (!peer || !peer.pc) {
                        addMessage('No active connection for ' + hostUser, 3000);
                        console.log('[WebRTC] No peer connection for:', hostUser);
                        return;
                    }
                    const answerEntry = data.batch.find(entry => entry.user === userName);
                    if (!answerEntry) {
                        addMessage('No answer for you in batch from ' + hostUser, 3000);
                        console.log('[WebRTC] No answer for user:', userName, 'in batch from:', hostUser);
                        return;
                    }
                    try {
                        await peer.pc.setRemoteDescription(new RTCSessionDescription(answerEntry.answer));
                        for (const candidate of answerEntry.iceCandidates || []) {
                            try {
                                await peer.pc.addIceCandidate(new RTCIceCandidate(candidate));
                            } catch (e) {
                                console.error('[WebRTC] Failed to add ICE candidate for:', hostUser, 'error:', e);
                            }
                        }
                        console.log('[WebRTC] Successfully processed batch answer for:', hostUser);
                        addMessage('Connected to ' + hostUser + ' via batch file', 5000);
                        updateHudButtons();
                        clearInterval(answerPollingIntervals.get('MCAnswer@' + userName + '@' + worldName));
                        answerPollingIntervals.delete('MCAnswer@' + userName + '@' + worldName);
                    } catch (e) {
                        console.error('[WebRTC] Failed to process batch answer for:', hostUser, 'error:', e);
                        addMessage('Failed to connect to ' + hostUser, 3000);
                    }
                } else {
                    addMessage('Invalid file format', 3000);
                    console.log('[WebRTC] Invalid file: no offer, answer, or batch');
                }
            } catch (e) {
                console.error('[WebRTC] Error processing file:', e);
                addMessage('Failed to process file', 3000);
            }
        }
        function setupDataChannel(dc, user) {
           console.log(`[WebRTC] Setting up data channel for: ${user}`);
            dc.onopen = () => {
                console.log(`[WebRTC] Data channel open with: ${user}. State: ${dc.readyState}`);
                addMessage(`Connection established with ${user}`, 3000);

                // Send initial player position
                dc.send(JSON.stringify({
                    type: 'player_move',
                    username: userName,
                    x: player.x,
                    y: player.y,
                    z: player.z,
                    yaw: player.yaw,
                    pitch: player.pitch,
                    isMoving: false,
                    isAttacking: false,
                    timestamp: Date.now()
                }));

                // If this is the host, send the current state of all mobs to the new client
                if (isHost) {
                    console.log(`[WebRTC] Host sending initial mob state to ${user}`);
                    for (const mob of mobs) {
                        dc.send(JSON.stringify({
                            type: 'mob_update',
                            id: mob.id,
                            x: mob.pos.x,
                            y: mob.pos.y,
                            z: mob.pos.z,
                            hp: mob.hp
                        }));
                    }
                }

                updateHudButtons();
            };
            dc.onmessage = e => {
                console.log(`[WebRTC] Message from ${user}:`, e.data.substring(0, 100));

                try {
                    const data = JSON.parse(e.data);
                    const sender = data.username || user; // Fallback to user if username is not in payload

                    if (sender === userName) return; // Ignore messages from self

                    // Host is the source of truth. It processes inputs and broadcasts state.
                    if (isHost) {
                        // Don't relay player_move, host will broadcast authoritative state.
                        if (data.type !== 'player_move') {
                            for (const [peerUser, peerData] of peers.entries()) {
                                if (peerUser !== sender && peerUser !== userName && peerData.dc && peerData.dc.readyState === 'open') {
                                    peerData.dc.send(e.data);
                                }
                            }
                        }
                    }

                    // All peers (host and clients) process the message to update their local state
                    let avatar = playerAvatars.get(sender);
                    if (!avatar && sender) {
                        avatar = createAvatar(sender);
                    }

                    switch (data.type) {
                        case 'state_update':
                            // Received from host, update all player states
                            if (!isHost) {
                                for (const playerData of data.players) {
                                    const remoteUser = playerData.username;
                                    if (remoteUser === userName) {
                                        // This is a correction from the server about our own position.
                                        // A more advanced implementation would use this for reconciliation.
                                        continue;
                                    }
                                    if (!userPositions[remoteUser]) {
                                        userPositions[remoteUser] = {};
                                        createAvatar(remoteUser);
                                    }
                                    const userState = userPositions[remoteUser];
                                    if (!data.timestamp || data.timestamp > (userState.lastTimestamp || 0)) {
                                        userState.prevX = userState.targetX;
                                        userState.prevY = userState.targetY;
                                        userState.prevZ = userState.targetZ;
                                        userState.prevYaw = userState.targetYaw;
                                        userState.prevPitch = userState.targetPitch;

                                        userState.targetX = playerData.x;
                                        userState.targetY = playerData.y;
                                        userState.targetZ = playerData.z;
                                        userState.targetYaw = playerData.yaw;
                                        userState.targetPitch = playerData.pitch;

                                        userState.isMoving = playerData.isMoving;
                                        userState.lastUpdate = performance.now();
                                        userState.lastTimestamp = data.timestamp;

                                        if (playerData.isAttacking && !userState.isAttacking) {
                                            userState.isAttacking = true;
                                            userState.attackStartTime = performance.now();
                                        }
                                    }
                                }
                            }
                            break;
                        case 'player_move':
                            // Host processes this to update its state for the client
                            if (!isHost) break;

                            if (!userPositions[sender]) {
                                userPositions[sender] = {
                                    lastTimestamp: 0,
                                    prevX: data.x, prevY: data.y, prevZ: data.z,
                                    prevYaw: data.yaw, prevPitch: data.pitch,
                                    targetX: data.x, targetY: data.y, targetZ: data.z,
                                    targetYaw: data.yaw, targetPitch: data.pitch
                                };
                            }
                            const userState = userPositions[sender];

                            // Interpolation and lag handling
                            if (data.timestamp > userState.lastTimestamp) {
                                // Store the previous state for interpolation
                                userState.prevX = userState.targetX;
                                userState.prevY = userState.targetY;
                                userState.prevZ = userState.targetZ;
                                userState.prevYaw = userState.targetYaw;
                                userState.prevPitch = userState.targetPitch;

                                // Set the new target state
                                userState.targetX = data.x;
                                userState.targetY = data.y;
                                userState.targetZ = data.z;
                                userState.targetYaw = data.yaw;
                                userState.targetPitch = data.pitch;

                                userState.isMoving = data.isMoving;
                                userState.lastUpdate = performance.now();
                                userState.lastTimestamp = data.timestamp;

                                if (data.isAttacking && !userState.isAttacking) {
                                    userState.isAttacking = true;
                                    userState.attackStartTime = performance.now();
                                }
                            }
                            break;
                        case 'block_change':
                             // Received a block change. If host, relay to other clients.
                            if (isHost) {
                                console.log(`[WebRTC] Host relaying block change from ${sender} to other peers.`);
                                for (const [peerUser, peerData] of peers.entries()) {
                                    if (peerUser !== sender && peerUser !== userName && peerData.dc && peerData.dc.readyState === 'open') {
                                        peerData.dc.send(e.data);
                                    }
                                }
                            }
                            // All peers (including host) apply the change locally.
                            // `doBroadcast` is false to prevent clients from re-broadcasting.
                            chunkManager.setBlockGlobal(data.wx, data.wy, data.wz, data.bid, false);
                            break;
                        case 'mob_update':
                            // Received from host. Update local mob state.
                            let mob = mobs.find(m => m.id === data.id);
                            if (!mob) {
                                mob = new Mob(data.x, data.z, data.id);
                                mobs.push(mob);
                            }
                            mob.pos.set(data.x, data.y, data.z);
                            mob.hp = data.hp;
                            if (data.flash) {
                                mob.flashEnd = Date.now() + 200;
                            }
                            break;
                        case 'mob_kill':
                            // Received from host. Remove mob locally.
                            const mobToKill = mobs.find(m => m.id === data.id);
                            if (mobToKill) {
                                try { scene.remove(mobToKill.mesh); disposeObject(mobToKill.mesh); } catch (e) {}
                                mobs = mobs.filter(m => m.id !== mobToKill.id);
                            }
                            break;
                        case 'mob_hit':
                            // Received from a client. Only the host processes this.
                            if (isHost) {
                                const mobToHit = mobs.find(m => m.id === data.id);
                                if (mobToHit) {
                                    mobToHit.hurt(data.damage || 4, data.username);
                                }
                            }
                            break;
                        case 'player_damage':
                            // Received from host. Apply damage to self.
                            if (Date.now() - lastDamageTime > 800) {
                                player.health = Math.max(0, player.health - (data.damage || 1));
                                lastDamageTime = Date.now();
                                document.getElementById('health').innerText = player.health;
                                updateHealthBar();
                                addMessage('Hit! HP: ' + player.health, 1000);
                                if (player.health <= 0) {
                                    handlePlayerDeath();
                                }
                            }
                            break;
                        case 'add_score':
                            // Received from host. Add score to self.
                            player.score += data.amount || 0;
                            document.getElementById('score').innerText = player.score;
                            addMessage(`+${data.amount} score`, 1500);
                            break;
                    }
                } catch (err) {
                    console.error(`[WebRTC] Failed to process message from ${user}:`, err);
                }
            };
            dc.onclose = () => {
                console.log(`[WebRTC] Data channel with ${user} closed. State: ${dc.readyState}`);
                addMessage(`Connection with ${user} lost`, 3000);
                peers.delete(user);
                const avatar = playerAvatars.get(user);
                if (avatar) {
                    scene.remove(avatar);
                    disposeObject(avatar);
                    playerAvatars.delete(user);
                }
                delete userPositions[user];
                updateHudButtons();
            };
            dc.onerror = e => {
                console.error(`[WebRTC] Data channel error with ${user}:`, e);
            };
        }
        function updatePendingModal() {
            var modal = document.getElementById('pendingModal');
            var list = document.getElementById('pendingList');
            list.innerHTML = '';
            for (var offer of pendingOffers) {
                var row = document.createElement('div');
                row.className = 'row';
                var info = document.createElement('div');
                info.innerText = offer.clientUser + ' at ' + new Date(offer.timestamp).toLocaleString();
                var checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'selectOffer';
                checkbox.dataset.user = offer.clientUser;
                row.appendChild(info);
                row.appendChild(checkbox);
                list.appendChild(row);
            }
            modal.style.display = isHost && pendingOffers.length > 0 ? 'block' : 'none';
        }
        async function acceptPendingOffers() {
    const checkboxes = document.querySelectorAll('.selectOffer:checked');
    if (checkboxes.length === 0) {
        addMessage('No offers selected', 3000);
        console.log('[WebRTC] No offers selected for acceptance');
        return;
    }
    const modal = document.getElementById('joinScriptModal');
    if (!modal) {
        console.error('[WebRTC] joinScriptModal not found in DOM');
        addMessage('UI error: Modal not found', 5000);
        return;
    }
    const batch = [];
    const users = [];
    // REMOVED: const serverPc = ...
    for (const checkbox of checkboxes) {
        const clientUser = checkbox.dataset.user;
        const offer = pendingOffers.find(o => o.clientUser === clientUser);
        if (!offer) {
            console.log('[WebRTC] No offer found for user:', clientUser);
            continue;
        }
        if (!offer.offer || !offer.offer.sdp || !offer.offer.type) {
            console.error('[WebRTC] Invalid offer data for:', clientUser, 'txId:', offer.transactionId);
            addMessage(`Invalid connection offer from ${clientUser || 'Unknown'}`, 3000);
            continue;
        }
        let answer = { type: 'answer', sdp: '' }; // Fallback
        let answerIceCandidates = [];
        try {
            const iceServers = await getTurnCredentials();
            const pc = new RTCPeerConnection({ iceServers });
            peers.set(clientUser, { pc, dc: null, address: offer.profile ? offer.profile.Creators[0] : null });
            pc.ondatachannel = (e) => {
                const dc = e.channel;
                const peerData = peers.get(clientUser);
                if (peerData) {
                    peerData.dc = dc;
                }
                setupDataChannel(dc, clientUser);
            };
            await pc.setRemoteDescription(new RTCSessionDescription(offer.offer));
            for (const candidate of offer.iceCandidates || []) {
                try {
                    await pc.addIceCandidate(new RTCIceCandidate(candidate));
                } catch (e) {
                    console.error('[WebRTC] Failed to add ICE candidate for:', clientUser, 'error:', e);
                }
            }
            answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            pc.onicecandidate = e => {
                if (e.candidate) answerIceCandidates.push(e.candidate);
            };
            await new Promise(resolve => {
                pc.onicegatheringstatechange = () => {
                    if (pc.iceGatheringState === 'complete') resolve();
                };
            });
            // Add state monitoring
            pc.onconnectionstatechange = () => {
                console.log('[WebRTC] Connection state for', clientUser, ':', pc.connectionState);
                if (pc.connectionState === 'connected') {
                    addMessage('Connected to ' + clientUser, 3000);
                } else if (pc.connectionState === 'failed') {
                    addMessage('Connection failed with ' + clientUser, 3000);
                    pc.close();
                    peers.delete(clientUser);
                }
            };
            pc.onsignalingstatechange = () => {
                console.log('[WebRTC] Signaling state for', clientUser, ':', pc.signalingState);
            };
            batch.push({
                user: clientUser,
                answer,
                iceCandidates: answerIceCandidates
            });
            users.push(clientUser);
        } catch (e) {
            console.error('[WebRTC] Failed to process offer for:', clientUser, 'error:', e);
            addMessage(`Failed to connect to ${clientUser || 'Unknown'}`, 3000);
        }
    }
    if (batch.length > 0) {
        const batchData = {
            world: worldName,
            user: userName,
            batch
        };
        try {
            const blob = new Blob([JSON.stringify(batchData)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${worldName}_batch_${Date.now()}.json`;
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);
            console.log('[WebRTC] Batch JSON downloaded successfully for users:', users);
        } catch (e) {
            console.error('[WebRTC] Failed to download batch JSON:', e);
            addMessage('Failed to download batch JSON', 5000);
        }
        const batchKeyword = 'MCBatch@' + userName + '@' + worldName;
        let batchAddr = null;
        try {
            batchAddr = await GetPublicAddressByKeyword(batchKeyword);
        } catch (e) {
            console.error('[WebRTC] Failed to fetch batch address:', e);
        }
        const addressText = batchAddr ? batchAddr.trim().replace(/"|'/g, '') : batchKeyword;
        modal.querySelector('h3').innerText = 'Batch Connection';
        modal.querySelector('p').innerText = `Copy this address and paste it into a Sup!? message To: field, attach the JSON file, and click 📢 to confirm connections.`;
        modal.querySelector('#joinScriptText').value = addressText;
        modal.style.display = 'block';
        isPromptOpen = true;
        addMessage('Batch connections processed for ' + users.join(', '), 5000);
        console.log('[WebRTC] Join script modal opened for batch with address:', addressText, 'users:', users);
        pendingOffers = pendingOffers.filter(o => !users.includes(o.clientUser));
        updatePendingModal();
    } else {
        addMessage('No valid offers processed', 3000);
        console.log('[WebRTC] No valid offers were processed for batch');
    }
}
        function setupPendingModal() {
            console.log('[Modal] Setting up pendingModal, pendingOffers:', pendingOffers.length);
            const existingModal = document.getElementById('pendingModal');
            if (existingModal) {
                existingModal.remove();
                console.log('[Modal] Removed existing pendingModal');
            }
            const modal = document.createElement('div');
            modal.id = 'pendingModal';
            modal.style.position = 'fixed';
            modal.style.right = '12px';
            modal.style.bottom = '12px';
            modal.style.zIndex = '220';
            modal.style.background = 'var(--panel)';
            modal.style.padding = '14px';
            modal.style.borderRadius = '10px';
            modal.style.minWidth = '300px';
            modal.style.maxWidth = '400px';
            modal.style.display = isHost && pendingOffers.length > 0 ? 'block' : 'none';
            modal.innerHTML = `
        <h3>Pending Connections</h3>
        <div id="pendingList"></div>
        <div class="actions">
            <label><input type="checkbox" id="acceptAll"> Accept All</label>
            <button id="acceptPending">Accept Selected</button>
            <button id="closePending">Close</button>
        </div>
    `;
            document.body.appendChild(modal);
            console.log('[Modal] pendingModal added to DOM');
            const list = modal.querySelector('#pendingList');
            list.style.maxHeight = 'calc(80vh - 100px)';
            list.style.overflow = 'auto';
            list.innerHTML = '';
            let hasEntries = false;
            const offerMap = new Map();
            for (const offer of pendingOffers) {
                if (offer.clientUser === userName) {
                    console.log('[Modal] Skipping offer from self:', offer.clientUser, 'txId:', offer.transactionId);
                    continue;
                }
                if (!offerMap.has(offer.clientUser)) {
                    offerMap.set(offer.clientUser, offer);
                }
            }
            const latestOffers = Array.from(offerMap.values());
            for (const offer of latestOffers) {
                console.log('[Modal] Rendering pending offer from:', offer.clientUser, 'txId:', offer.transactionId);
                const row = document.createElement('div');
                row.className = 'row';
                row.style.maxHeight = '80px';
                row.style.display = 'flex';
                row.style.alignItems = 'center';
                row.style.marginBottom = '8px';
                const info = document.createElement('div');
                info.innerText = `${offer.clientUser || 'Unknown'} at ${new Date(offer.timestamp).toLocaleString()}\nBio: ${offer.profile && offer.profile.Bio ? offer.profile.Bio : 'No bio'}`;
                info.style.whiteSpace = 'pre-line';
                info.style.maxWidth = '200px';
                info.style.maxHeight = '60px';
                info.style.overflow = 'hidden';
                info.style.textOverflow = 'ellipsis';
                info.style.flex = '1';
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'selectOffer';
                checkbox.dataset.user = offer.clientUser || '';
                checkbox.dataset.transactionId = offer.transactionId;
                checkbox.style.margin = '0 8px';
                const acceptBtn = document.createElement('button');
                acceptBtn.innerText = 'Accept';
                acceptBtn.style.marginRight = '8px';
                acceptBtn.onclick = () => {
                    console.log('[WebRTC] Accepting offer from:', offer.clientUser, 'txId:', offer.transactionId);
                    checkbox.checked = true;
                    acceptPendingOffers();
                };
                const rejectBtn = document.createElement('button');
                rejectBtn.innerText = 'Reject';
                rejectBtn.style.background = 'var(--danger)';
                rejectBtn.style.color = '#111';
                rejectBtn.onclick = () => {
                    console.log('[WebRTC] Rejecting offer from:', offer.clientUser, 'txId:', offer.transactionId);
                    pendingOffers = pendingOffers.filter(o => o.clientUser !== offer.clientUser);
                    addMessage(`Rejected connection from ${offer.clientUser || 'Unknown'}`, 3000);
                    setupPendingModal();
                };
                row.appendChild(info);
                row.appendChild(checkbox);
                row.appendChild(acceptBtn);
                row.appendChild(rejectBtn);
                list.appendChild(row);
                hasEntries = true;
            }
            if (!hasEntries) {
                console.log('[Modal] No pending offers to render');
                const empty = document.createElement('div');
                empty.style.marginTop = '8px';
                empty.innerText = 'No pending connection requests';
                list.appendChild(empty);
            }
            const acceptAll = modal.querySelector('#acceptAll');
            if (acceptAll) {
                acceptAll.addEventListener('change', e => {
                    document.querySelectorAll('.selectOffer').forEach(ch => { ch.checked = e.target.checked; });
                    console.log('[Modal] Accept All checkbox changed');
                });
            }
            const acceptPending = modal.querySelector('#acceptPending');
            if (acceptPending) {
                acceptPending.onclick = async () => {
                    console.log('[Modal] Accept Pending clicked');
                    await acceptPendingOffers();
                };
            }
            modal.querySelector('#closePending').onclick = () => {
                console.log('[Modal] Closing pendingModal');
                modal.style.display = 'none';
                isPromptOpen = false;
            };
        }
        function startOfferPolling() {
            if (!isHost) {
                console.log('[WebRTC] Not hosting, skipping offer polling');
                return;
            }
            console.log('[WebRTC] Starting offer polling for:', userName);
            var offerKeyword = 'MCConn@' + userName + '@' + worldName;
            var apiDelay = 350;
            var interval = setInterval(async function () {
                try {
                    await new Promise(resolve => setTimeout(resolve, apiDelay));
                    console.log('[WebRTC] Polling offers for:', offerKeyword);
                    worker.postMessage({
                        type: 'poll',
                        chunkKeys: [],
                        masterKey: MASTER_WORLD_KEY,
                        userAddress: userAddress,
                        worldName: worldName,
                        serverKeyword: 'MCServerJoin@' + worldName,
                        offerKeyword: offerKeyword,
                        answerKeywords: [],
                        userName: userName
                    });
                } catch (e) {
                    console.error('[WebRTC] Error in offer polling:', e);
                }
            }, 30000);
            offerPollingIntervals.set(offerKeyword, interval);
        }
        function startAnswerPolling(hostUser) {
            var keyword = 'MCAnswer@' + userName + '@' + worldName;
            if (answerPollingIntervals.has(keyword)) return;
            console.log('[WebRTC] Starting answer polling for:', hostUser);
            answerPollingIntervals.set(keyword, setInterval(function () {
                worker.postMessage({
                    type: 'poll',
                    chunkKeys: [],
                    masterKey: MASTER_WORLD_KEY,
                    userAddress: userAddress,
                    worldName: worldName,
                    serverKeyword: 'MCServerJoin@' + worldName,
                    offerKeyword: null,
                    answerKeywords: [keyword],
                    userName: userName
                });
                if (Date.now() - connectionAttempts.get(hostUser) > 1800000) {
                    console.log('[WebRTC] Answer polling timeout for:', hostUser);
                    addMessage('Connection to ' + hostUser + ' timed out after 30 minutes.', 5000);
                    clearInterval(answerPollingIntervals.get(keyword));
                    answerPollingIntervals.delete(keyword);
                    var peer = peers.get(hostUser);
                    if (peer && peer.pc) peer.pc.close();
                    peers.delete(hostUser);
                    if (playerAvatars.has(hostUser)) {
                        scene.remove(playerAvatars.get(hostUser));
                        disposeObject(playerAvatars.get(hostUser));
                        playerAvatars.delete(hostUser);
                    }
                    delete userPositions[hostUser];
                    updateHudButtons();
                }
            }, 30000));
        }
        async function pollServers() {
            if (isInitialLoad) {
                console.log('[WebRTC] Skipping poll, initial load not complete');
                return;
            }
            console.log('[WebRTC] Polling server announcements for:', 'MCServerJoin@' + worldName);
            var serverKeyword = 'MCServerJoin@' + worldName;
            var retries = 0;
            var maxRetries = 3;
            var retryDelay = 5000;
            var apiDelay = 350;
            async function tryFetchMessages() {
                var serverAddr;
                try {
                    await new Promise(resolve => setTimeout(resolve, apiDelay));
                    serverAddr = await GetPublicAddressByKeyword(serverKeyword);
                } catch (e) {
                    console.error('[WebRTC] Failed to fetch server address:', e);
                }
                if (!serverAddr) {
                    if (retries < maxRetries) {
                        retries++;
                        setTimeout(tryFetchMessages, retryDelay * Math.pow(2, retries));
                    } else {
                        addMessage('Failed to fetch server announcements', 3000);
                        console.error('[WebRTC] Max retries reached for server announcements');
                    }
                    return;
                }
                var messages = [];
                var skip = 0;
                var qty = 5000;
                while (true) {
                    try {
                        await new Promise(resolve => setTimeout(resolve, apiDelay));
                        var response = await GetPublicMessagesByAddress(serverAddr, skip, qty);
                        if (!response || response.length === 0) break;
                        messages = messages.concat(response);
                        if (response.length < qty) break;
                        skip += qty;
                    } catch (e) {
                        console.error('[WebRTC] Failed to fetch server messages, skip:', skip, 'error:', e);
                        break;
                    }
                }
                var newServers = [];
                var transactionIds = [];
                var messageMap = new Map();
                for (var msg of messages) {
                    if (!msg.TransactionId || processedMessages.has(msg.TransactionId)) {
                        if (msg.TransactionId) {
                            console.log('[WebRTC] Stopping server message processing at cached ID:', msg.TransactionId);
                            break; // Stop processing as all remaining messages are older
                        }
                        continue;
                    }
                    transactionIds.push(msg.TransactionId);
                    var fromAddress = msg.FromAddress;
                    var timestamp = Date.parse(msg.BlockDate) || Date.now();
                    var existing = messageMap.get(fromAddress);
                    if (!existing || existing.timestamp < timestamp) {
                        messageMap.set(fromAddress, { msg: msg, timestamp: timestamp });
                    }
                }
                for (var entry of messageMap) {
                    var msg = entry[1].msg;
                    var timestamp = entry[1].timestamp;
                    try {
                        await new Promise(resolve => setTimeout(resolve, apiDelay));
                        var fromProfile = await GetProfileByAddress(msg.FromAddress);
                        if (!fromProfile || !fromProfile.URN) {
                            console.log('[WebRTC] Skipping server message, no URN for address:', msg.FromAddress, 'transactionId:', msg.TransactionId);
                            continue;
                        }
                        var hostUser = fromProfile.URN.replace(/[^a-zA-Z0-9]/g, '');
                        await new Promise(resolve => setTimeout(resolve, apiDelay));
                        var userProfile = await GetProfileByURN(hostUser);
                        if (!userProfile) {
                            console.log('[WebRTC] No profile for user:', hostUser, 'transactionId:', msg.TransactionId);
                        } else if (!userProfile.Creators || !userProfile.Creators.includes(msg.FromAddress)) {
                            console.log('[WebRTC] Skipping server message, invalid creators for user:', hostUser, 'transactionId:', msg.TransactionId);
                            continue;
                        }
                        var spawn = calculateSpawnPoint(hostUser + '@' + worldName);
                        var offer = null;
                        var iceCandidates = [];
                        var match = msg.Message.match(/IPFS:([a-zA-Z0-9]+)/);
                        if (match) {
                            var hash = match[1];
                            var cidRegex = /^[A-Za-z0-9]{46}$|^[A-Za-z0-9]{59}$|^[a-z0-9]+$/;
                            if (cidRegex.test(hash)) {
                                try {
                                    await new Promise(resolve => setTimeout(resolve, apiDelay));
                                    var data = await fetchIPFS(hash);
                                    if (data && data.offer && data.world === worldName) {
                                        offer = data.offer;
                                        iceCandidates = data.iceCandidates || [];
                                    }
                                } catch (e) {
                                    console.error('[WebRTC] Failed to fetch IPFS for hash:', hash, 'error:', e, 'transactionId:', msg.TransactionId);
                                }
                            }
                        }
                        if (!knownServers.some(s => s.hostUser === hostUser && s.transactionId === msg.TransactionId)) {
                            newServers.push({
                                hostUser: hostUser,
                                spawn: spawn,
                                offer: offer,
                                iceCandidates: iceCandidates,
                                transactionId: msg.TransactionId,
                                timestamp: timestamp,
                                connectionRequestCount: 0,
                                latestRequestTime: null
                            });
                            processedMessages.add(msg.TransactionId);
                        }
                    } catch (e) {
                        console.error('[WebRTC] Error processing server message:', msg.TransactionId, e);
                    }
                }
                console.log('[WebRTC] New server announcements:', transactionIds);
                var serverMap = new Map();
                for (var server of knownServers.concat(newServers)) {
                    if (!serverMap.has(server.hostUser) || serverMap.get(server.hostUser).timestamp < server.timestamp) {
                        serverMap.set(server.hostUser, server);
                    }
                }
                knownServers = Array.from(serverMap.values()).sort(function (a, b) { return b.timestamp - a.timestamp; }).slice(0, 10);
                if (newServers.length > 0) {
                    addMessage('New player(s) available to connect!', 3000);
                    updateHudButtons();
                }
            }
            tryFetchMessages();
        }
        async function initServers() {
            console.log('[WebRTC] Initializing servers for:', worldName);
            var serverKeyword = 'MCServerJoin@' + worldName;
            var responseKeywords = [];
            var serverAddr;
            try {
                serverAddr = await GetPublicAddressByKeyword(serverKeyword);
            } catch (e) {
                console.error('[WebRTC] Failed to fetch initial server address:', e);
            }
            if (!serverAddr) {
                console.error('[WebRTC] No server address for:', serverKeyword);
                return;
            }
            console.log('[WebRTC] Fetching initial server announcements for:', serverKeyword);
            var messages = [];
            var skip = 0;
            var qty = 5000;
            var apiDelay = 350;
            while (true) {
                try {
                    await new Promise(resolve => setTimeout(resolve, apiDelay));
                    var response = await GetPublicMessagesByAddress(serverAddr, skip, qty);
                    if (!response || response.length === 0) break;
                    messages = messages.concat(response);
                    if (response.length < qty) break;
                    skip += qty;
                } catch (e) {
                    console.error('[WebRTC] Failed to fetch initial server messages, skip:', skip, 'error:', e);
                    break;
                }
            }
            console.log('[WebRTC] Initial poll: Cached server announcements:', messages.map(m => m.TransactionId));
            var messageMap = new Map();
            for (var msg of messages) {
                if (!msg.TransactionId || processedMessages.has(msg.TransactionId)) {
                    if (msg.TransactionId) {
                        console.log('[WebRTC] Stopping server message processing at cached ID:', msg.TransactionId);
                        break; // Stop processing as all remaining messages are older
                    }
                    continue;
                }
                processedMessages.add(msg.TransactionId);
                var timestamp = Date.parse(msg.BlockDate) || Date.now();
                var existing = messageMap.get(msg.FromAddress);
                if (!existing || existing.timestamp < timestamp) {
                    messageMap.set(msg.FromAddress, { msg: msg, timestamp: timestamp });
                }
            }
            for (var entry of messageMap) {
                var msg = entry[1].msg;
                var timestamp = entry[1].timestamp;
                try {
                    await new Promise(resolve => setTimeout(resolve, apiDelay));
                    var fromProfile = await GetProfileByAddress(msg.FromAddress);
                    if (!fromProfile || !fromProfile.URN) {
                        console.log('[WebRTC] Skipping initial server message, no URN for address:', msg.FromAddress, 'transactionId:', msg.TransactionId);
                        continue;
                    }
                    var hostUser = fromProfile.URN.replace(/[^a-zA-Z0-9]/g, '');
                    await new Promise(resolve => setTimeout(resolve, apiDelay));
                    var userProfile = await GetProfileByURN(hostUser);
                    if (!userProfile) {
                        console.log('[WebRTC] No profile for user:', hostUser, 'transactionId:', msg.TransactionId);
                    } else if (!userProfile.Creators || !userProfile.Creators.includes(msg.FromAddress)) {
                        console.log('[WebRTC] Skipping initial server message, invalid creators for user:', hostUser, 'transactionId:', msg.TransactionId);
                        continue;
                    }
                    var spawn = calculateSpawnPoint(hostUser + '@' + worldName);
                    var offer = null;
                    var iceCandidates = [];
                    var match = msg.Message.match(/IPFS:([a-zA-Z0-9]+)/);
                    if (match) {
                        var hash = match[1];
                        var cidRegex = /^[A-Za-z0-9]{46}$|^[A-Za-z0-9]{59}$|^[a-z0-9]+$/;
                        if (cidRegex.test(hash)) {
                            try {
                                await new Promise(resolve => setTimeout(resolve, apiDelay));
                                var data = await fetchIPFS(hash);
                                if (data && data.offer && data.world === worldName) {
                                    offer = data.offer;
                                    iceCandidates = data.iceCandidates || [];
                                }
                            } catch (e) {
                                console.error('[WebRTC] Failed to fetch IPFS for hash:', hash, 'error:', e, 'transactionId:', msg.TransactionId);
                            }
                        }
                    }
                    if (!knownServers.some(s => s.hostUser === hostUser && s.transactionId === msg.TransactionId)) {
                        knownServers.push({
                            hostUser: hostUser,
                            spawn: spawn,
                            offer: offer,
                            iceCandidates: iceCandidates,
                            transactionId: msg.TransactionId,
                            timestamp: timestamp,
                            connectionRequestCount: 0,
                            latestRequestTime: null
                        });
                    }
                    responseKeywords.push('MCConn@' + hostUser + '@' + worldName);
                } catch (e) {
                    console.error('[WebRTC] Error processing initial server message:', msg.TransactionId, e);
                }
            }
            var serverMap = new Map();
            for (var server of knownServers) {
                if (!serverMap.has(server.hostUser) || serverMap.get(server.hostUser).timestamp < server.timestamp) {
                    serverMap.set(server.hostUser, server);
                }
            }
            knownServers = Array.from(serverMap.values()).sort(function (a, b) { return b.timestamp - a.timestamp; }).slice(0, 10);
            if (isHost) {
                responseKeywords.push('MCConn@' + userName + '@' + worldName);
            }
            for (var responseKeyword of responseKeywords) {
                var responseAddr;
                try {
                    await new Promise(resolve => setTimeout(resolve, apiDelay));
                    responseAddr = await GetPublicAddressByKeyword(responseKeyword);
                } catch (e) {
                    console.error('[WebRTC] Failed to fetch initial response address for:', responseKeyword, e);
                }
                if (responseAddr) {
                    var messages = [];
                    var skip = 0;
                    var qty = 5000;
                    while (true) {
                        try {
                            await new Promise(resolve => setTimeout(resolve, apiDelay));
                            var response = await GetPublicMessagesByAddress(responseAddr, skip, qty);
                            if (!response || response.length === 0) break;
                            messages = messages.concat(response);
                            if (response.length < qty) break;
                            skip += qty;
                        } catch (e) {
                            console.error('[WebRTC] Failed to fetch initial response messages for:', responseKeyword, 'skip:', skip, 'error:', e);
                            break;
                        }
                    }
                    console.log('[WebRTC] Initial poll: Cached', messages.length, 'existing responses for:', responseKeyword, messages.map(m => m.TransactionId));
                    for (var msg of messages) {
                        if (msg.TransactionId && processedMessages.has(msg.TransactionId)) {
                            console.log('[WebRTC] Stopping response message processing at cached ID:', msg.TransactionId);
                            break; // Stop processing as all remaining messages are older
                        }
                        if (msg.TransactionId) {
                            processedMessages.add(msg.TransactionId);
                            console.log('[WebRTC] Caching transactionId on initial load:', msg.TransactionId, 'for:', responseKeyword);
                        }
                    }
                    var requestCount = messages.length;
                    var latestRequest = messages.length > 0 ? Date.parse(messages[0].BlockDate) || Date.now() : null;
                    var hostUser = responseKeyword.match(/MCConn@(.+)@[^@]+$/)[1];
                    var server = knownServers.find(function (s) { return s.hostUser === hostUser; });
                    if (server) {
                        server.connectionRequestCount = requestCount;
                        server.latestRequestTime = latestRequest;
                    }
                }
            }
            // Process offers only for host's keyword if isHost
            if (isHost) {
                var hostKeyword = 'MCConn@' + userName + '@' + worldName;
                var responseAddr = await GetPublicAddressByKeyword(hostKeyword);
                if (responseAddr) {
                    var messages = [];
                    var skip = 0;
                    var qty = 5000;
                    while (true) {
                        try {
                            await new Promise(resolve => setTimeout(resolve, apiDelay));
                            var response = await GetPublicMessagesByAddress(responseAddr, skip, qty);
                            if (!response || response.length === 0) break;
                            messages = messages.concat(response);
                            if (response.length < qty) break;
                            skip += qty;
                        } catch (e) {
                            console.error('[WebRTC] Failed to fetch initial host offer messages for:', hostKeyword, 'skip:', skip, 'error:', e);
                            break;
                        }
                    }
                    var newOffers = [];
                    for (var msg of messages) {
                        if (msg.TransactionId && processedMessages.has(msg.TransactionId)) {
                            console.log('[WebRTC] Stopping host offer processing at cached ID:', msg.TransactionId);
                            break; // Stop processing as all remaining messages are older
                        }
                        if (!msg.TransactionId) continue;
                        processedMessages.add(msg.TransactionId);
                        try {
                            var fromProfile = await GetProfileByAddress(msg.FromAddress);
                            if (!fromProfile || !fromProfile.URN) {
                                console.log('[WebRTC] Skipping initial offer message, no URN for address:', msg.FromAddress, 'txId:', msg.TransactionId);
                                continue;
                            }
                            var clientUser = fromProfile.URN.replace(/[^a-zA-Z0-9]/g, '');
                            var userProfile = await GetProfileByURN(clientUser);
                            if (!userProfile) {
                                console.log('[WebRTC] No profile for user:', clientUser, 'txId:', msg.TransactionId);
                                continue;
                            }
                            if (!userProfile.Creators || !userProfile.Creators.includes(msg.FromAddress)) {
                                console.log('[WebRTC] Skipping initial offer message, invalid creators for user:', clientUser, 'txId:', msg.TransactionId);
                                continue;
                            }
                            var match = msg.Message.match(/IPFS:([a-zA-Z0-9]+)/);
                            if (!match) {
                                console.log('[WebRTC] No IPFS hash in initial offer message:', msg.Message, 'txId:', msg.TransactionId);
                                continue;
                            }
                            var hash = match[1];
                            var cidRegex = /^[A-Za-z0-9]{46}$|^[A-Za-z0-9]{59}$|^[a-z0-9]+$/;
                            if (!cidRegex.test(hash)) {
                                console.log('[WebRTC] Invalid CID in initial offer message:', hash, 'txId:', msg.TransactionId);
                                continue;
                            }
                            try {
                                await new Promise(resolve => setTimeout(resolve, apiDelay));
                                var data = await fetchIPFS(hash);
                                if (!data || !data.world || data.world !== worldName) {
                                    console.log('[WebRTC] Invalid IPFS data for initial offer message:', hash, 'data:', JSON.stringify(data), 'txId:', msg.TransactionId);
                                    continue;
                                }
                                if (data.offer || data.answer) {
                                    newOffers.push({
                                        clientUser: data.user || clientUser,
                                        offer: data.offer || data.answer,
                                        iceCandidates: data.iceCandidates || [],
                                        transactionId: msg.TransactionId,
                                        timestamp: Date.parse(msg.BlockDate) || Date.now(),
                                        profile: fromProfile
                                    });
                                }
                            } catch (e) {
                                console.error('[WebRTC] Failed to fetch IPFS for initial offer hash:', hash, 'error:', e, 'txId:', msg.TransactionId);
                            }
                        } catch (e) {
                            console.error('[WebRTC] Error processing initial offer message:', msg.TransactionId, e);
                        }
                    }
                    if (newOffers.length > 0) {
                        pendingOffers.push(...newOffers);
                        setupPendingModal();
                    }
                }
            }
            console.log('[WebRTC] Initial load complete, processedMessages:', Array.from(processedMessages));
            worker.postMessage({ type: 'sync_processed', ids: Array.from(processedMessages) });
            isInitialLoad = false;
        }
        function openUsersModal() {
            console.log('[Modal] Opening users modal, knownServers:', knownServers.length, 'peers:', Array.from(peers.keys()), 'pendingOffers:', pendingOffers.length);
            var existingModal = document.getElementById('usersModal');
            if (existingModal) {
                existingModal.remove();
                console.log('[Modal] Removed existing usersModal');
            }
            var modal = document.createElement('div');
            modal.id = 'usersModal';
            modal.style.position = 'fixed';
            modal.style.left = '50%';
            modal.style.top = '50%';
            modal.style.transform = 'translate(-50%,-50%)';
            modal.style.zIndex = '220';
            modal.style.background = 'var(--panel)';
            modal.style.padding = '14px';
            modal.style.borderRadius = '10px';
            modal.style.minWidth = '360px';
            modal.style.display = 'block';
            modal.innerHTML = `
        <h3>Online Players</h3>
        <div style="margin-bottom:10px;">
            <input id="friendHandle" placeholder="Enter friend’s handle" style="width:100%;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:#0d1620;color:#fff;box-sizing:border-box;" autocomplete="off">
            <button id="connectFriend" style="width:100%;padding:10px;margin-top:8px;border-radius:8px;background:var(--accent);color:#111;border:0;font-weight:700;cursor:pointer;">Connect to Friend</button>
        </div>
        <div id="usersList"></div>
        <p class="warning">Note: Servers may be offline. Connection requires the host to be active. Recent attempts increase success likelihood.</p>
        <div style="margin-top:10px;text-align:right;">
            <button id="closeUsers">Close</button>
        </div>
    `;
            document.body.appendChild(modal);
            console.log('[Modal] Modal added to DOM');
            var list = modal.querySelector('#usersList');
            list.innerHTML = '';
            var hasEntries = false;

            var connectedHeader = document.createElement('h4');
            connectedHeader.innerText = 'Connected Players';
            list.appendChild(connectedHeader);
            for (var peer of peers) {
                var peerUser = peer[0];
                if (peerUser !== userName) {
                    hasEntries = true;
                    console.log('[Modal] Rendering peer:', peerUser);
                    var spawn = calculateSpawnPoint(peerUser + '@' + worldName);
                    var row = document.createElement('div');
                    row.style.display = 'flex';
                    row.style.gap = '8px';
                    row.style.alignItems = 'center';
                    row.style.marginTop = '8px';
                    var info = document.createElement('div');
                    info.innerText = peerUser + ' (Connected) at (' + Math.floor(spawn.x) + ', ' + Math.floor(spawn.y) + ', ' + Math.floor(spawn.z) + ')';
                    var btn = document.createElement('button');
                    btn.innerText = 'Visit Spawn';
                    btn.onclick = function () {
                        console.log('[Modal] Teleporting to spawn of:', peerUser);
                        respawnPlayer(spawn.x, 100, spawn.z);
                        modal.style.display = 'none';
                        isPromptOpen = false;
                    };
                    row.appendChild(info);
                    row.appendChild(btn);
                    list.appendChild(row);
                }
            }

            var activeServersHeader = document.createElement('h4');
            activeServersHeader.innerText = 'Known Servers (Last 10)';
            list.appendChild(activeServersHeader);
            var serverMap = new Map();
            for (var server of knownServers) {
                if (!serverMap.has(server.hostUser) || serverMap.get(server.hostUser).timestamp < server.timestamp) {
                    serverMap.set(server.hostUser, server);
                }
            }
            var uniqueServers = Array.from(serverMap.values()).sort(function (a, b) { return b.timestamp - a.timestamp; }).slice(0, 10);
            for (var server of uniqueServers) {
                hasEntries = true;
                console.log('[Modal] Rendering server:', server.hostUser, 'at:', JSON.stringify(server.spawn));
                var row = document.createElement('div');
                row.style.display = 'flex';
                row.style.gap = '8px';
                row.style.alignItems = 'center';
                row.style.marginTop = '8px';
                var info = document.createElement('div');
                var attemptTime = connectionAttempts.get(server.hostUser);
                info.innerText = server.hostUser + ' at (' + Math.floor(server.spawn.x) + ', ' + Math.floor(server.spawn.y) + ', ' + Math.floor(server.spawn.z) + ')\nServer started: ' + new Date(server.timestamp).toLocaleString() + '\nLast connect attempt: ' + (attemptTime ? new Date(attemptTime).toLocaleString() : 'Never') + '\nConnection requests: ' + (server.connectionRequestCount || 0) + '\nLatest request: ' + (server.latestRequestTime ? new Date(server.latestRequestTime).toLocaleString() : 'None');
                info.style.whiteSpace = 'pre-line';
                if (!peers.has(server.hostUser) && (!isHost || server.hostUser !== userName)) {
                    var btn = document.createElement('button');
                    btn.innerText = 'Try Connect';
                    btn.onclick = async function () {
                        console.log('[WebRTC] Attempting to connect to server:', server.hostUser);
                        addMessage("Finding a route to " + server.hostUser + "...", 5000);
                        await connectToServer(server.hostUser, server.offer, server.iceCandidates);
                        modal.style.display = 'none';
                        isPromptOpen = false;
                    };
                    row.appendChild(btn);
                }
                row.appendChild(info);
                list.appendChild(row);
            }

            if (isHost) {
                var pendingHeader = document.createElement('h4');
                pendingHeader.innerText = 'Pending Connections';
                list.appendChild(pendingHeader);
                for (var offer of pendingOffers) {
                    var row = document.createElement('div');
                    row.style.display = 'flex';
                    row.style.gap = '8px';
                    row.style.alignItems = 'center';
                    row.style.marginTop = '8px';
                    var info = document.createElement('div');
                    info.innerText = offer.clientUser + ' at ' + new Date(offer.timestamp).toLocaleString() + '\nBio: ' + (offer.profile && offer.profile.Bio ? offer.profile.Bio : 'No bio');
                    info.style.whiteSpace = 'pre-line';
                    row.appendChild(info);
                    list.appendChild(row);
                    hasEntries = true;
                }
            }
            if (!hasEntries) {
                console.log('[Modal] No servers or peers to render in modal');
                var empty = document.createElement('div');
                empty.style.marginTop = '8px';
                empty.innerText = 'No players available';
                list.appendChild(empty);
            }
            modal.querySelector('#closeUsers').onclick = function () {
                console.log('[Modal] Closing users modal');
                modal.remove();
                isPromptOpen = false;
            };
            modal.querySelector('#friendHandle').addEventListener('keydown', function(e) {
                e.stopPropagation();
            });
            modal.querySelector('#connectFriend').onclick = function () {
                var handle = document.getElementById('friendHandle').value.replace(/[^a-zA-Z0-9]/g, '').slice(0, 20);
                if (!handle) {
                    addMessage('Please enter a friend’s handle', 3000);
                    return;
                }
                if (handle === userName) {
                    addMessage('Cannot connect to yourself', 3000);
                    return;
                }
                console.log('[WebRTC] Attempting to connect to friend:', handle);
                // Add friend to knownServers with a temporary entry
                var spawn = calculateSpawnPoint(handle + '@' + worldName);
                knownServers.push({
                    hostUser: handle,
                    spawn: spawn,
                    offer: null,
                    iceCandidates: [],
                    transactionId: 'local_' + Date.now(),
                    timestamp: Date.now(),
                    connectionRequestCount: 0,
                    latestRequestTime: null
                });
                connectToServer(handle, null, []);
                modal.style.display = 'none';
                isPromptOpen = false;
            };
        }
        document.addEventListener('DOMContentLoaded', function () {
            try {
                console.log('[Debug] DOMContentLoaded fired, initializing login elements');
                var startBtn = document.getElementById('startBtn');
                var announceLoginBtn = document.getElementById('announceLoginBtn');
                var newUserJoinScriptBtn = document.getElementById('newUserJoinScriptBtn');
                var acceptAll = document.getElementById('acceptAll');
                var pendingModal = document.getElementById('pendingModal');
                var loginOverlay = document.getElementById('loginOverlay');
                if (!startBtn || !announceLoginBtn || !newUserJoinScriptBtn || !loginOverlay) {
                    console.error('[Debug] Login buttons or overlay not found in DOM');
                    addMessage('UI initialization failed: buttons or overlay missing', 3000);
                    return;
                }
                if (acceptAll) {
                    acceptAll.addEventListener('change', function (e) {
                        document.querySelectorAll('.selectOffer').forEach(function (ch) { ch.checked = e.target.checked; });
                        console.log('[Debug] Accept All checkbox changed');
                    });
                } else {
                    console.warn('[Debug] acceptAll element not found');
                }
                if (pendingModal) {
                    pendingModal.addEventListener('click', function (e) { e.stopPropagation(); });
                    console.log('[Debug] Pending modal click listener added');
                } else {
                    console.warn('[Debug] pendingModal element not found');
                }
                startBtn.addEventListener('click', async function () {
                    console.log('[Login] Start button clicked');
                    isPromptOpen = false;
                    var worldInput = document.getElementById('worldNameInput').value;
                    var userInput = document.getElementById('userInput').value;
                    if (worldInput.length > 8) {
                        addMessage('World name too long (max 8 chars)', 3000);
                        return;
                    }
                    if (userInput.length > 20) {
                        addMessage('Username too long (max 20 chars)', 3000);
                        return;
                    }
                    if (!worldInput || !userInput) {
                        addMessage('Please enter a world and username', 3000);
                        return;
                    }
                    worldName = worldInput.replace(/[^a-zA-Z0-9]/g, '').slice(0, 8).toUpperCase();
                    userName = userInput.replace(/[^a-zA-Z0-9]/g, '').slice(0, 20);
                    worldSeed = worldName;
                    var userWorldKey = userName + '@' + worldName;
                    var profile = await GetProfileByURN(userName);
                    userAddress = profile && profile.Creators ? profile.Creators[0] : 'anonymous';
                    if (!knownUsers.has(userName)) knownUsers.set(userName, userAddress);
                    if (!knownWorlds.has(worldName)) {
                        knownWorlds.set(worldName, { discoverer: userName, users: new Set([userName]), toAddress: userAddress });
                    } else {
                        knownWorlds.get(worldName).users.add(userName);
                    }
                    keywordCache.set(userAddress, userWorldKey);
                    document.getElementById('loginOverlay').style.display = 'none';
                    document.getElementById('hud').style.display = 'block';
                    document.getElementById('hotbar').style.display = 'flex';
                    document.getElementById('rightPanel').style.display = 'flex';
                    document.getElementById('worldLabel').textContent = worldName;
                    document.getElementById('seedLabel').textContent = 'User ' + userName;
                    updateHudButtons();
                    console.log('[Login] Initializing Three.js');
                    initThree();
                    console.log('[Login] Three.js initialized');
                    initHotbar();
                    console.log('[Login] Creating ChunkManager');
                    chunkManager = new ChunkManager(worldSeed);
                    console.log('[Login] Populating spawn chunks');
                    populateSpawnChunks();
                    console.log('[Login] Calculating spawn point');
                    var spawn = calculateSpawnPoint(userWorldKey);
                    player.x = spawn.x;
                    player.y = spawn.y;
                    player.z = spawn.z;
                    spawnPoint = { x: player.x, y: player.y, z: player.z };
                    player.vy = 0;
                    player.onGround = true;
                    var chunksPerSide = Math.floor(MAP_SIZE / CHUNK_SIZE);
                    var spawnCx = Math.floor(spawn.x / CHUNK_SIZE);
                    var spawnCz = Math.floor(spawn.z / CHUNK_SIZE);
                    console.log('[Login] Preloading initial chunks');
                    chunkManager.preloadChunks(spawnCx, spawnCz, LOAD_RADIUS);
                    console.log('[Login] Spawning mobs');
                    const mobRnd = makeSeededRandom(worldSeed + '_mobs');
                    spawnMobs(12, mobRnd);
                    setupMobile();
                    initMinimap();
                    updateHotbarUI();
                    selectedBlockId = null;
                    cameraMode = 'first';
                    controls.enabled = false;
                    avatarGroup.visible = false;
                    camera.position.set(player.x, player.y + 1.62, player.z);
                    camera.rotation.set(0, 0, 0, 'YXZ');
                    if (!isMobile()) {
                        try {
                            renderer.domElement.requestPointerLock();
                            mouseLocked = true;
                            document.getElementById('crosshair').style.display = 'block';
                        } catch (e) {
                            addMessage('Pointer lock failed. Serve over HTTPS or ensure allow-pointer-lock is set in iframe.', 3000);
                        }
                    }
                    player.yaw = 0;
                    player.pitch = 0;
                    lastFrame = performance.now();
                    lastRegenTime = lastFrame;
                    var unregisterKeyEvents = registerKeyEvents();
                    console.log('[Login] Starting game loop');
                    requestAnimationFrame(gameLoop);
                    addMessage('Welcome — world wraps at edges. Toggle camera with T. Good luck!', 5000);
                    var healthElement = document.getElementById('health');
                    if (healthElement) healthElement.innerText = player.health;
                    var scoreElement = document.getElementById('score');
                    if (scoreElement) scoreElement.innerText = player.score;
                    await initServers();
                    worker.postMessage({ type: 'sync_processed', ids: Array.from(processedMessages) });
                    startWorker();
                    setInterval(pollServers, POLL_INTERVAL);
                    addMessage('Joined world ' + worldName + ' as ' + userName, 3000);
                });
                announceLoginBtn.addEventListener('click', async function () {
                    console.log('[Login] Announce Server button clicked');
                    isPromptOpen = true;
                    var worldInput = document.getElementById('worldNameInput').value;
                    var userInput = document.getElementById('userInput').value;
                    if (worldInput.length > 8) {
                        addMessage('World name too long (max 8 chars)', 3000);
                        return;
                    }
                    if (userInput.length > 20) {
                        addMessage('Username too long (max 20 chars)', 3000);
                        return;
                    }
                    if (!worldInput || !userInput) {
                        addMessage('Please enter a world and username', 3000);
                        return;
                    }
                    var cleanWorld = worldInput.replace(/[^a-zA-Z0-9]/g, '').slice(0, 8).toUpperCase();
                    var cleanUser = userInput.replace(/[^a-zA-Z0-9]/g, '').slice(0, 20);
                    var serverKeyword = 'MCServerJoin@' + cleanWorld;
                    var serverAddr = await GetPublicAddressByKeyword(serverKeyword);
                    document.getElementById('joinScriptText').value = serverAddr ? serverAddr.trim().replace(/^"|"$/g, '') : serverKeyword;
                    document.getElementById('joinScriptModal').style.display = 'block';
                    document.getElementById('joinScriptModal').querySelector('h3').innerText = 'Announce Server';
                    document.getElementById('joinScriptModal').querySelector('p').innerText = 'Copy this address and paste it into a Sup!? message To: field, attach a server JSON file after starting, and click 📢 to announce your server.';
                    addMessage('Prepare to announce server after starting', 3000);
                });
                newUserJoinScriptBtn.addEventListener('click', async function () {
                    console.log('[Login] Create Join Script button clicked');
                    isPromptOpen = true;
                    var worldInput = document.getElementById('worldNameInput').value;
                    var userInput = document.getElementById('userInput').value;
                    if (worldInput.length > 8) {
                        addMessage('World name too long (max 8 chars)', 3000);
                        return;
                    }
                    if (userInput.length > 20) {
                        addMessage('Username too long (max 20 chars)', 3000);
                        return;
                    }
                    if (!worldInput || !userInput) {
                        addMessage('Please enter a world and username', 3000);
                        return;
                    }
                    var cleanWorld = worldInput.replace(/[^a-zA-Z0-9]/g, '').slice(0, 8).toUpperCase();
                    var cleanUser = userInput.replace(/[^a-zA-Z0-9]/g, '').slice(0, 20);
                    var userWorldKey = cleanUser + '@' + cleanWorld;
                    var existingWorld = knownWorlds.get(cleanWorld);
                    if (existingWorld && existingWorld.users.has(cleanUser)) {
                        addMessage('User already in this world. Choose a different username.', 3000);
                        return;
                    }
                    var userAddr = await GetPublicAddressByKeyword(userWorldKey);
                    var masterAddr = await GetPublicAddressByKeyword(MASTER_WORLD_KEY);
                    var addresses = [
                        userAddr ? userAddr.trim() : userWorldKey,
                        masterAddr ? masterAddr.trim() : MASTER_WORLD_KEY
                    ].filter(function (a) { return a; });
                    var joinScript = addresses.join(',').replace(/["']/g, '');
                    document.getElementById('joinScriptText').value = joinScript;
                    document.getElementById('joinScriptModal').style.display = 'block';
                    document.getElementById('joinScriptModal').querySelector('h3').innerText = 'Join World';
                    document.getElementById('joinScriptModal').querySelector('p').innerText = 'Copy this address and paste it into a Sup!? message To: field and click 📢 to join the world.';
                    addMessage('Join script ready to share', 3000);
                });
                document.getElementById('homeIcon').addEventListener('click', function () {
                    respawnPlayer();
                });
                document.getElementById('camToggle').addEventListener('click', toggleCameraMode);
                document.getElementById('openCraft').addEventListener('click', openCrafting);
                document.getElementById('teleportBtn').addEventListener('click', function () {
                    isPromptOpen = true;
                    document.getElementById('teleportModal').style.display = 'block';
                    document.getElementById('teleportX').value = '';
                    document.getElementById('teleportY').value = '';
                    document.getElementById('teleportZ').value = '';
                });
                document.getElementById('saveChangesBtn').addEventListener('click', downloadSession);
                document.getElementById('joinScriptBtn').addEventListener('click', async function () {
                    isPromptOpen = true;
                    var userAddr = await GetPublicAddressByKeyword(userName + '@' + worldName);
                    var masterAddr = await GetPublicAddressByKeyword(MASTER_WORLD_KEY);
                    var joinScript = [userAddr || (userName + '@' + worldName), masterAddr || MASTER_WORLD_KEY].filter(function (a) { return a; }).join(',').replace(/["']/g, '');
                    document.getElementById('joinScriptText').value = joinScript;
                    document.getElementById('joinScriptModal').style.display = 'block';
                });
                document.getElementById('announceBtn').addEventListener('click', announceServer);
                document.getElementById('usersBtn').addEventListener('click', openUsersModal);
                document.getElementById('closeCraft').addEventListener('click', function () {
                    isPromptOpen = false;
                    document.getElementById('craftModal').style.display = 'none';
                });
                document.getElementById('closeJoinScript').addEventListener('click', function () {
                    isPromptOpen = false;
                    document.getElementById('joinScriptModal').style.display = 'none';
                });
                document.getElementById('closeDownloadModal').addEventListener('click', function () {
                    isPromptOpen = false;
                    document.getElementById('downloadModal').style.display = 'none';
                });
                document.getElementById('teleportCancel').addEventListener('click', function () {
                    isPromptOpen = false;
                    document.getElementById('teleportModal').style.display = 'none';
                });
                document.getElementById('teleportOk').addEventListener('click', function () {
                    var x = parseFloat(document.getElementById('teleportX').value);
                    var y = parseFloat(document.getElementById('teleportY').value);
                    var z = parseFloat(document.getElementById('teleportZ').value);
                    if (isNaN(x) || isNaN(y) || isNaN(z)) {
                        addMessage('Invalid coordinates', 3000);
                        return;
                    }
                    respawnPlayer(x, y, z);
                    document.getElementById('teleportModal').style.display = 'none';
                    isPromptOpen = false;
                });
                document.getElementById('respawnBtn').addEventListener('click', function () {
                    respawnPlayer();
                });
                document.getElementById('acceptPending').addEventListener('click', acceptPendingOffers);
                document.getElementById('closePending').addEventListener('click', function () {
                    document.getElementById('pendingModal').style.display = 'none';
                    pendingOffers = [];
                    updatePendingModal();
                });
                async function initWorldsAndUsers() {
                    console.log('[Users] Initializing worlds and users for:', MASTER_WORLD_KEY);
                    var masterAddr = await GetPublicAddressByKeyword(MASTER_WORLD_KEY);
                    if (masterAddr) {
                        var messages = await GetPublicMessagesByAddress(masterAddr);
                        for (var msg of messages || []) {
                            if (msg.TransactionId && !processedMessages.has(msg.TransactionId)) {
                                console.log('[Users] Processing message:', msg.TransactionId);
                                var fromProfile = await GetProfileByAddress(msg.FromAddress);
                                if (!fromProfile || !fromProfile.URN) {
                                    console.log('[Users] Skipping: No valid URN for address:', msg.FromAddress);
                                    continue;
                                }
                                var user = fromProfile.URN.replace(/[^a-zA-Z0-9]/g, '');
                                var userProfile = await GetProfileByURN(user);
                                if (!userProfile || !userProfile.Creators || !userProfile.Creators.includes(msg.FromAddress)) {
                                    console.log('[Users] Skipping: Invalid profile for user:', user);
                                    continue;
                                }
                                var toKeywordRaw = await GetKeywordByPublicAddress(msg.ToAddress);
                                if (!toKeywordRaw) {
                                    console.log('[Users] Skipping: No keyword for address:', msg.ToAddress);
                                    continue;
                                }
                                var toKeyword = toKeywordRaw.replace(/^"|"$/g, '');
                                if (!toKeyword.includes('MCUserJoin@')) {
                                    console.log('[Users] Skipping: Invalid keyword:', toKeyword);
                                    continue;
                                }
                                var world = toKeyword.split('@')[1].replace(/[^a-zA-Z0-9]/g, '');
                                if (user && world) {
                                    console.log('[Users] Adding user:', user, 'to world:', world);
                                    if (!knownWorlds.has(world)) {
                                        knownWorlds.set(world, { discoverer: user, users: new Set([user]), toAddress: msg.ToAddress });
                                    } else {
                                        knownWorlds.get(world).users.add(user);
                                    }
                                    if (!knownUsers.has(user)) knownUsers.set(user, msg.FromAddress);
                                    spawnChunks.set(user, { cx: null, cz: null, username: user, world: world });
                                    processedMessages.add(msg.TransactionId);
                                }
                            } else if (msg.TransactionId) {
                                console.log('[Users] Skipping processed message:', msg.TransactionId);
                            }
                        }
                        console.log('[Users] Discovered worlds:', knownWorlds.size, 'users:', knownUsers.size);
                    }
                }
                initWorldsAndUsers();
                updateLoginUI();
                console.log('[Debug] DOMContentLoaded completed, button listeners attached');
            } catch (error) {
                console.error('[Debug] Error in DOMContentLoaded:', error);
                addMessage('Failed to initialize login system', 3000);
            }
        });
        function animateAttack() {
            if (!isAttacking) {
                isAttacking = true;
                attackStartTime = performance.now();
            }
        }

        function updateAvatarAnimation(now, isMoving) {
            if (!avatarGroup) return;

            const walkSpeed = 0.005;
            const walkAmplitude = 0.5;
            const attackSpeed = 0.01;
            const attackAmplitude = 1.5;
            const attackDuration = 500;

            if (isAttacking) {
                const elapsedTime = now - attackStartTime;
                if (elapsedTime < attackDuration) {
                    const angle = Math.sin((elapsedTime / attackDuration) * Math.PI) * attackAmplitude;
                    avatarGroup.children[4].rotation.x = angle; // left arm
                    avatarGroup.children[5].rotation.x = angle; // right arm
                } else {
                    isAttacking = false;
                    avatarGroup.children[4].rotation.x = 0;
                    avatarGroup.children[5].rotation.x = 0;
                }
            } else if (isMoving) {
                const angle = Math.sin(now * walkSpeed) * walkAmplitude;
                avatarGroup.children[0].rotation.x = angle; // left leg
                avatarGroup.children[1].rotation.x = -angle; // right leg
                avatarGroup.children[4].rotation.x = -angle; // left arm
                avatarGroup.children[5].rotation.x = angle; // right arm
            } else {
                avatarGroup.children[0].rotation.x = 0;
                avatarGroup.children[1].rotation.x = 0;
                avatarGroup.children[4].rotation.x = 0;
                avatarGroup.children[5].rotation.x = 0;
            }
        }

        function initMinimap() {
            var canvas = document.getElementById('minimap');
            minimapCtx = canvas.getContext('2d');
            canvas.width = 120;
            canvas.height = 120;
            updateMinimap();
            // Create hidden file input for double-click upload
            var fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = '.json';
            fileInput.style.display = 'none';
            document.body.appendChild(fileInput);
            // Double-click handler to trigger file selection
            canvas.addEventListener('dblclick', function () {
                console.log('[Minimap] Double-click detected, triggering file upload');
                fileInput.click();
            });
            // Drag-and-drop handlers
            canvas.addEventListener('dragover', function (e) {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'copy';
                canvas.style.border = '2px dashed var(--accent)';
            });
            canvas.addEventListener('dragleave', function () {
                canvas.style.border = '1px solid rgba(255,255,255,0.1)';
            });
            canvas.addEventListener('drop', async function (e) {
                e.preventDefault();
                canvas.style.border = '1px solid rgba(255,255,255,0.1)';
                const files = e.dataTransfer.files;
                for (const file of files) {
                    if (file && file.type === 'application/json') {
                        console.log('[Minimap] File dropped:', file.name);
                        await handleMinimapFile(file);
                    } else {
                        addMessage('Skipped non-JSON file: ' + (file ? file.name : 'unknown'), 3000);
                        console.log('[Minimap] Invalid file dropped:', file ? file.type : 'no file');
                    }
                }
            });
            // File input change handler
            fileInput.addEventListener('change', async function () {
                if (fileInput.files.length > 0) {
                    for (const file of fileInput.files) {
                        console.log('[Minimap] File selected via double-click:', file.name);
                        await handleMinimapFile(file);
                    }
                    fileInput.value = ''; // Reset input
                }
            });
            console.log('[Minimap] Events attached: double-click and drag-and-drop enabled');
        }
        function gameLoop(now) {
            var dt = Math.min(0.06, (now - lastFrame) / 1000);
            lastFrame = now;
            if (player.health <= 0) {
                handlePlayerDeath();
            }
            if (deathScreenShown) {
                mobs.forEach(function (m) { m.update(dt); });
                updateSky(dt);
                updateMinimap();
                var scoreElement = document.getElementById('score');
                if (scoreElement) scoreElement.innerText = player.score;
                renderer.render(scene, camera);
            } else {
                var speed = 4.3;
                var mvx = 0, mvz = 0;
                if (isMobile()) {
                    if (joystick.up) mvz -= 1;
                    if (joystick.down) mvz += 1;
                    if (joystick.left) mvx -= 1;
                    if (joystick.right) mvx += 1;
                } else {
                    if (keys['s']) mvz -= 1;
                    if (keys['w']) mvz += 1;
                    if (keys['a']) mvx -= 1;
                    if (keys['d']) mvx += 1;

                    // Arrow key camera controls
                    if (keys['arrowup']) player.pitch += 0.02;
                    if (keys['arrowdown']) player.pitch -= 0.02;
                    if (keys['arrowleft']) player.yaw += 0.02;
                    if (keys['arrowright']) player.yaw -= 0.02;
                    player.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, player.pitch));
                    camera.rotation.set(player.pitch, player.yaw, 0, 'YXZ');
                }
                var forwardDir, rightDir;
                if (cameraMode === 'first') {
                    forwardDir = new THREE.Vector3(0, 0, -1).applyEuler(new THREE.Euler(player.pitch, player.yaw, 0, 'YXZ'));
                    forwardDir.y = 0;
                    forwardDir.normalize();
                    rightDir = new THREE.Vector3().crossVectors(forwardDir, new THREE.Vector3(0, 1, 0)).normalize();
                } else {
                    forwardDir = new THREE.Vector3(-Math.sin(player.yaw), 0, -Math.cos(player.yaw)).normalize();
                    rightDir = new THREE.Vector3().crossVectors(new THREE.Vector3(0, 1, 0), forwardDir).normalize();
                }
                var moveVec = new THREE.Vector3();
                moveVec.addScaledVector(forwardDir, mvz);
                moveVec.addScaledVector(rightDir, mvx);
                const isMoving = moveVec.length() > 0.001;
                if (isMoving) moveVec.normalize();
                var dx = moveVec.x * speed * dt;
                var dz = moveVec.z * speed * dt;
                var newX = modWrap(player.x + dx, MAP_SIZE);
                var newZ = modWrap(player.z + dz, MAP_SIZE);
                if (!checkCollision(newX, player.y, newZ)) {
                    player.x = newX;
                    player.z = newZ;
                } else {
                    if (!checkCollision(newX, player.y, player.z)) player.x = newX;
                    if (!checkCollision(player.x, player.y, newZ)) player.z = newZ;
                }
                player.vy -= 16.0 * dt;
                var dy = player.vy * dt;
                var newY = player.y + dy;
                if (!checkCollision(player.x, newY, newZ)) {
                    player.y = newY;
                    player.onGround = false;
                } else {
                    if (dy < 0) {
                        player.y = Math.ceil(newY - 0.001);
                        player.vy = 0;
                        player.onGround = true;
                    } else if (dy > 0) {
                        player.y = Math.floor(newY + player.height) - player.height;
                        player.vy = 0;
                    }
                }
                if (checkCollision(player.x, player.y, player.z)) {
                    if (!pushPlayerOut()) {
                        player.y = chunkManager.getSurfaceY(player.x, player.z) + 1;
                        player.vy = 0;
                        player.onGround = true;
                        addMessage('Stuck in block, respawned');
                    }
                }
                if (player.y < -10) {
                    player.x = modWrap(player.x, MAP_SIZE);
                    player.z = modWrap(player.z, MAP_SIZE);
                    player.y = chunkManager.getSurfaceY(player.x, player.z) + 1;
                    player.vy = 0;
                    player.onGround = true;
                    addMessage('Fell off world, respawned');
                }
                if (Date.now() - lastDamageTime > 30000 && Date.now() - lastRegenTime > 10000 && player.health < 20) {
                    player.health = Math.min(20, player.health + 1);
                    lastRegenTime = Date.now();
                    var healthElement = document.getElementById('health');
                    if (healthElement) healthElement.innerText = player.health;
                    updateHealthBar();
                    addMessage('Health regenerated: ' + player.health, 1000);
                }
                var distFromSpawn = Math.hypot(player.x - spawnPoint.x, player.z - spawnPoint.z);
                document.getElementById('homeIcon').style.display = distFromSpawn > 10 ? 'inline' : 'none';
                avatarGroup.position.set(player.x, player.y - 0.9, player.z);
                if (cameraMode === 'third') {
                    avatarGroup.rotation.y = player.yaw;
                }
                updateAvatarAnimation(now, isMoving);
                chunkManager.update(player.x, player.z);
                mobs.forEach(function (m) { m.update(dt); });
                updateSky(dt);
                updateMinimap();
                var posLabel = document.getElementById('posLabel');
                if (posLabel) posLabel.innerText = Math.floor(player.x) + ', ' + Math.floor(player.y) + ', ' + Math.floor(player.z);
                if (cameraMode === 'third') {
                    controls.target.set(player.x, player.y + 0.6, player.z);
                    controls.update();
                } else {
                    var headPos = new THREE.Vector3(player.x, player.y + 1.62, player.z);
                    camera.position.copy(headPos);
                }
                const positionChanged = Math.hypot(player.x - lastSentPosition.x, player.y - lastSentPosition.y, player.z - lastSentPosition.z) > 0.1;
                const rotationChanged = Math.abs(player.yaw - lastSentPosition.yaw) > 0.01 || Math.abs(player.pitch - lastSentPosition.pitch) > 0.01;

                if (now - lastUpdateTime > 50 && (positionChanged || rotationChanged)) {
                    lastUpdateTime = now;
                    lastSentPosition = { x: player.x, y: player.y, z: player.z, yaw: player.yaw, pitch: player.pitch };
                    const message = {
                        type: 'player_move',
                        username: userName,
                        x: player.x, y: player.y, z: player.z,
                        yaw: player.yaw, pitch: player.pitch,
                        isMoving: isMoving, isAttacking: isAttacking,
                        timestamp: Date.now()
                    };
                    // Client sends its own movement to the host
                    if (!isHost) {
                        for (const [peerUser, peerData] of peers.entries()) {
                            if (peerData.dc && peerData.dc.readyState === 'open') {
                                peerData.dc.send(JSON.stringify(message));
                            }
                        }
                    }
                }

                // Host broadcasts the authoritative state of all players
                if (isHost && now - lastStateUpdateTime > 100) {
                    lastStateUpdateTime = now;
                    const playersData = [];
                    // Add host's state
                    playersData.push({
                        username: userName,
                        x: player.x, y: player.y, z: player.z,
                        yaw: player.yaw, pitch: player.pitch,
                        isMoving: isMoving, isAttacking: isAttacking
                    });
                    // Add clients' states
                    for (const [username, positionData] of Object.entries(userPositions)) {
                        if (peers.has(username)) { // Ensure the user is still connected
                             playersData.push({
                                username: username,
                                x: positionData.targetX, y: positionData.targetY, z: positionData.targetZ,
                                yaw: positionData.targetYaw, pitch: positionData.targetPitch,
                                isMoving: positionData.isMoving, isAttacking: positionData.isAttacking
                            });
                        }
                    }

                    const stateUpdateMessage = {
                        type: 'state_update',
                        timestamp: Date.now(),
                        players: playersData
                    };

                    const messageString = JSON.stringify(stateUpdateMessage);
                    for (const [peerUser, peerData] of peers.entries()) {
                        if (peerUser !== userName && peerData.dc && peerData.dc.readyState === 'open') {
                            peerData.dc.send(messageString);
                        }
                    }
                }
                for (var entry of playerAvatars) {
                    var username = entry[0];
                    var avatar = entry[1];
                    if (username !== userName && userPositions[username]) {
                        const userState = userPositions[username];

                        // Interpolate position
                        if (userState.prevX !== undefined) {
                            const now = performance.now();
                            const timeSinceUpdate = now - userState.lastUpdate;
                            const interpolationDelay = 100; // ms
                            const alpha = Math.min(1.0, timeSinceUpdate / interpolationDelay);

                            const interpolatedPosition = new THREE.Vector3(
                                userState.prevX + (userState.targetX - userState.prevX) * alpha,
                                userState.prevY + (userState.targetY - userState.prevY) * alpha - 0.9,
                                userState.prevZ + (userState.targetZ - userState.prevZ) * alpha
                            );
                            avatar.position.copy(interpolatedPosition);

                            // Interpolate rotation using quaternions for smooth slerp
                            const prevQuaternion = new THREE.Quaternion().setFromEuler(new THREE.Euler(userState.prevPitch, userState.prevYaw, 0, 'YXZ'));
                            const targetQuaternion = new THREE.Quaternion().setFromEuler(new THREE.Euler(userState.targetPitch, userState.targetYaw, 0, 'YXZ'));
                            THREE.Quaternion.slerp(prevQuaternion, targetQuaternion, avatar.quaternion, alpha);

                        } else if (userState.targetX !== undefined) {
                             // If no previous state, just jump to target
                            avatar.position.set(userState.targetX, userState.targetY - 0.9, userState.targetZ);
                            avatar.rotation.set(userState.targetPitch, userState.targetYaw, 0, 'YXZ');
                        }


                        const now = performance.now();
                        if (userState.isAttacking) {
                            const elapsedTime = now - userState.attackStartTime;
                            const attackDuration = 500;
                            if (elapsedTime < attackDuration) {
                                const angle = Math.sin((elapsedTime / attackDuration) * Math.PI) * 1.5;
                                avatar.children[4].rotation.x = angle; // left arm
                                avatar.children[5].rotation.x = angle; // right arm
                            } else {
                                userState.isAttacking = false;
                            }
                        } else if (userState.isMoving) {
                            const angle = Math.sin(now * 0.005) * 0.5;
                            avatar.children[0].rotation.x = angle; // left leg
                            avatar.children[1].rotation.x = -angle; // right leg
                            avatar.children[4].rotation.x = -angle; // left arm
                            avatar.children[5].rotation.x = angle; // right arm
                        } else {
                            avatar.children[0].rotation.x = 0;
                            avatar.children[1].rotation.x = 0;
                            avatar.children[4].rotation.x = 0;
                            avatar.children[5].rotation.x = 0;
                        }

                        avatar.visible = Math.hypot(player.x - avatar.position.x, player.z - avatar.position.z) < 32;
                    }
                }
                renderer.render(scene, camera);
            }
            requestAnimationFrame(gameLoop);
        }
        console.log('[Debug] Script loaded');
    </script>
</body>
</html>